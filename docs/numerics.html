<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Numerics</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Numerics</h1>
</header>
<p>As is oftentimes the case when aiming to model realistic physical
systems, the equations of motion presented here do not admit closed-form
analytical solutions. As such, we must rely on numerical methods and
computer simulations to solve them. Specifically, we solve <span
class="math inline">\(N\)</span> independent sets of Hamilton’s
equations, each consisting of six first-order, coupled differential
equations.</p>
<p>Numerical integration presents several challenges. First, there is
the practical question: how do we actually solve these equations? How
can we be confident that our numerical solutions faithfully approximate
the true dynamics, especially when the true solution is unknown? How do
we handle performance, data volume, or the trade-offs between speed and
accuracy?</p>
<p>To do this, I chose to write my own code, <code>tstrippy</code>,
despite other codes on the market already existing <span
class="citation"
data-cites="2013A&amp;A...557A..84P 2015ApJS..216...29B 2015MNRAS.450.4070W 2017JOSS....2..388P 2018arXiv180208255V">(Pelupessy
et al. 2013; Bovy 2015; Wang et al. 2015; Price-Whelan 2017; Vasiliev
2018)</span>. My motivation was part practical: I wanted to avoid
installation difficulties, steep learning curves, and uncertainty over
whether existing tools could implement my specific setup. But above all
else, I wanted to try my hand at it.</p>
<p>This chapter documents how we solve the equations of motion
numerically, how we validate the accuracy of the solutions, and how the
code is organized under the hood.</p>
<h1 id="astronomical-units-and-scaling">Astronomical units and
scaling</h1>
<p>When writing any code, the choice of units is important. Astronomical
units are rarely the same as SI units. Their creation were often times
observationally and historically motivated, resulting in a system that
uses multiple units for the same physical quantity, which can be
confusing at first.</p>
<p>For instance, sky positions are typically reported in spherical
coordinates. Right ascension (analogous to longitude) is often expressed
in either degrees or hours, while declination (similar to latitude) is
given in degrees. Distances are reported in parsecs when derived from
parallax measurements. Line-of-sight velocities, obtained via
spectroscopic Doppler shifts, are reported in kilometers per second.
Proper motions describe angular displacements over time on the sky and
are usually reported in milliarcseconds per year. Already, we encounter
several different units for angles (degrees, hours, arcseconds), time
(years, seconds), and distance (km, kpc), none of which align with SI’s
standard units of radians, seconds, or meters, as summarized in Table <a
href="#tab:units" data-reference-type="ref"
data-reference="tab:units">1</a>.</p>
<div id="tab:units">
<table>
<caption>Units for various astronomical quantities in Galactic and SI
systems.</caption>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Distance</th>
<th style="text-align: left;">RA</th>
<th style="text-align: left;">DEC</th>
<th style="text-align: left;"><strong><span
class="math inline">\(\mathrm{v}_\mathrm{LOS}\)</span></strong></th>
<th style="text-align: left;"><span
class="math inline">\(\mu_\alpha\)</span></th>
<th style="text-align: left;"><span
class="math inline">\(\mu_\delta\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Galactic:</td>
<td style="text-align: left;"><span>[</span>kpc<span>]</span></td>
<td style="text-align: left;"><span>[</span>deg<span>]</span>
<span>[</span>HHMMSS<span>]</span></td>
<td style="text-align: left;"><span>[</span>deg<span>]</span></td>
<td style="text-align: left;">km/s</td>
<td style="text-align: left;"><span>[</span>mas/yr<span>]</span></td>
<td style="text-align: left;"><span>[</span>mas/yr<span>]</span></td>
</tr>
<tr>
<td style="text-align: left;">S.I.</td>
<td style="text-align: left;"><span>[</span>m<span>]</span></td>
<td style="text-align: left;"><span>[</span>rad<span>]</span></td>
<td style="text-align: left;"><span>[</span>rad<span>]</span></td>
<td style="text-align: left;">m/s</td>
<td style="text-align: left;"><span>[</span>rad/s<span>]</span></td>
<td style="text-align: left;"><span>[</span>rad/s<span>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>This raises practical concerns—for example, what would be the unit of
acceleration? km/s<span class="math inline">\(^2\)</span>?
parsec/year/second? To systematically manage units, we turn to
dimensional analysis, notably the Buckingham Pi theorem <span
class="citation" data-cites="1914PhRv....4..345B">(Buckingham
1914)</span>. In classical mechanics, physical quantities are typically
expressed in terms of three fundamental dimensions: length, time, and
mass. Any quantity can then be represented as a product of powers of
these base units: <span
class="math display">\[\left[\mathrm{Quantity}\right] = l^a t^b m^c =
            \begin{bmatrix}
                a\\
                b\\
                c
            \end{bmatrix}\]</span> For example, velocity has dimensions
<span class="math inline">\([1, -1, 0]\)</span>, momentum is <span
class="math inline">\([1, -1, 1]\)</span>, and acceleration is <span
class="math inline">\([1, -2, 0]\)</span>.</p>
<p>It is not strictly necessary to adopt length-time-mass as the
fundamental basis, as long as the three chosen base units are linearly
independent. In stellar dynamics, it is often more natural to use
distance, velocity, and mass as the base units. In this thesis, we
adopt:</p>
<ul>
<li><p>Distance: 1 kpc</p></li>
<li><p>Velocity: 1 km/s</p></li>
<li><p>Mass: 1 solar mass <span
class="math inline">\(\mathrm{M}_\odot\)</span></p></li>
</ul>
<p>In this system, time has derived units of: <span
class="math display">\[\left[t\right] =
\frac{\mathrm{distance}}{\mathrm{velocity}} =
\frac{\mathrm{kpc}}{\mathrm{km/s}}.\]</span> While not immediately
intuitive, this unit of time is convenient because: <span
class="math display">\[1\mathrm{Gyr} \approx
1~\mathrm{s}\cdot\frac{\mathrm{kpc}}{\mathrm{km}}.\]</span> The
gravitational constant has dimensions: <span
class="math display">\[\left[G\right]=\frac{v^2 \cdot l}{m},\]</span>
which evaluates numerically to: <span class="math display">\[G = 4.301
\times 10^{-6} \left(\mathrm{km}/\mathrm{s}\right)^2 \cdot \mathrm{kpc}
\cdot \mathrm{M}_\odot^{-1}.\]</span> Once the base units are defined,
derived quantities such as acceleration follow directly. Whether
considering acceleration as <span
class="math inline">\(v^2~l^{-1}\)</span> or <span
class="math inline">\(l \cdot t^{-2}\)</span>, they are equivalent and
yield: <span
class="math inline">\(\left(\mathrm{kpc}/\mathrm{s}\right)^2 \cdot
\mathrm{kpc}^{-1}\)</span>.</p>
<p>It is worth mentioning that <span
class="math inline">\(N\)</span>-body codes often select distance,
velocity, and the gravitational constant as the base units, setting
<span class="math inline">\(G = 1\)</span>. While this choice simplifies
force computations, it introduces less intuitive units for mass. For
instance, by choosing 1 kpc for distance and 1 km/s for velocity, and
setting <span class="math inline">\(G = 1\)</span>, the derived mass
unit becomes: <span class="math display">\[\left[\mathrm{mass}\right] =
\frac{l \cdot v^2}{G} = 232509~\mathrm{M}_\odot.\]</span> This approach
was used in our first paper (see Chapter 4). The famous galactic
dynamical python code, <code>Galpy</code>, makes a different choice and
introduced <em>natural units</em> <span class="citation"
data-cites="2015ApJS..216...29B">(Bovy 2015)</span>. More specifically,
<span class="citation" data-cites="2015ApJS..216...29B">Bovy
(2015)</span> uses a normalization in which <span
class="math inline">\(R\)</span>, the cylindrical scale length of the
galaxy, and <span class="math inline">\(v_\mathrm{circ}\)</span>, the
circular velocity at this radius, are both set to 1. This choice is
motivated by a galaxy’s rotation curve and is embodied in: <span
class="math display">\[\frac{v_\mathrm{circ}^2}{R_0} = \nabla  \Phi
\left(R_0, z=0\right).
        \label{eq:vcirc}\]</span> Note that the gravitational constant
is also set to 1. Whatever the form of the potential, the scale lengths
must be normalized to <span class="math inline">\(R\)</span>, and the
mass parameter is subsequently determined through Eq. <a
href="#eq:vcirc" data-reference-type="ref"
data-reference="eq:vcirc">[eq:vcirc]</a>. The total potential is a
linear combination of individual components, with the user selecting the
contribution of each component to the force at the characteristic
radius. For example, <span class="math inline">\(\Phi = \sum_i
a_i\Phi_i\)</span>, where <span class="math inline">\(a_i\)</span> are
weights such that <span class="math inline">\(\nabla \Phi_i(R_0, z=0) =
a_i\)</span> in normalized units. In this system of units, emphasis is
placed on the rotation curve and how much each component contributes to
it at the reference radius of the galaxy. Note that <span
class="math inline">\(v_\mathrm{circ}(R_0)\)</span> is not necessarily
the maximum rotational velocity.</p>
<p>In short, each code presents its own preferred units and
normalization. <code>Tstrippy</code>, by contrast, expects the user to
pass masses in solar masses, velocities in kilometers per second, and
distances in kiloparsecs. However, physical constants are not
hard-coded, so the user may pass any numerical values to the code as
long as they are based on a self-consistent unit system. Nonetheless,
the code comes equipped with parameters for the
<code>pouliasis2017pii</code> potential <span class="citation"
data-cites="2017A&amp;A...598A..66P">(Pouliasis, Di Matteo, and Haywood
2017)</span> and for the catalog of globular clusters <span
class="citation" data-cites="2018MNRAS.478.1520B">(Baumgardt and Hilker
2018)</span> in units of kpc, km/s, and <span
class="math inline">\(\mathrm{M}_\odot\)</span>.</p>
<p>A valid general strategy when developing numerical codes is to
implement a module that converts user-defined units to the internal
units. This functionality also exists in <code>Galpy</code> and a
similar system is implemented in <code>Agama</code> <span
class="citation" data-cites="2018arXiv180208255V">(Vasiliev
2018)</span>. I chose not to add such a layer to <code>Tstrippy</code>
since <code>Astropy</code> provides an excellent unit-handling module
that allows users to convert between units easily <span class="citation"
data-cites="2013A&amp;A...558A..33A">(Astropy Collaboration et al.
2013)</span>, and I recommend its use in the documentation.</p>
<h1 id="solving-the-equations-of-motion">Solving the equations of
motion</h1>
<p>Long before the advent of computers, Euler (1707-1783) proposed a
simple method for numerically solving differential equations. In this
method, a solution is approximated by <span
class="math display">\[y_{i+1} = y_i + \Delta t
\frac{dy}{dt}\left(y_i,t_i\right),\]</span> where <span
class="math inline">\(i\)</span> is a timestep index. This means that at
each point <span class="math inline">\((t_i, y_i)\)</span>, the function
is extrapolated forward using a linear approximation.</p>
<p>The accuracy of this method can be understood using a Taylor series
expansion of the exact solution <span class="math inline">\(y(t_i +
\Delta t)\)</span> about <span class="math inline">\(t_i\)</span>: <span
class="math display">\[y(t_i + \Delta t) = y(t_i) + \Delta t y&#39;(t_i)
+ \frac{1}{2!}\Delta t^2 y&#39;&#39;(t_i) + \dots\]</span> Euler’s
method captures only the first two terms. The difference between the
exact solution and the Euler estimate is dominated by the second-order
term. Thus, the <em>local truncation error</em> (error per step) is
<span class="math display">\[\mathrm{Err}_{\mathrm{step}} \approx
\frac{1}{2} \Delta t^2 y&#39;&#39;(t_i) = \mathcal{O}(\Delta
t^2).\]</span></p>
<p>The <em>global error</em> (accumulated over many steps) is
approximately the number of steps times the average error per step:
<span class="math display">\[\mathrm{Err} \approx N_{\mathrm{step}}
\cdot \langle \mathrm{Err}_{\mathrm{step}} \rangle \approx
\frac{T}{\Delta t} \cdot \Delta t^2 \langle y&#39;&#39; \rangle =
\mathcal{O}(\Delta t).\]</span> This means that halving the timestep
roughly halves the global error.</p>
<p>It is important to note that using a Taylor series to estimate the
error is not mathematically rigorous and not always generalizable. The
actual error behavior depends strongly on the properties of the function
being integrated. For instance:</p>
<ul>
<li><p>If <span class="math inline">\(y\)</span> is linear in <span
class="math inline">\(t\)</span>, then <span
class="math inline">\(y&#39;\)</span> is constant and Euler’s method
gives the exact result.</p></li>
<li><p>If <span class="math inline">\(y(t) = t^a\)</span>, the local
errors accumulate and grow monotonically.</p></li>
<li><p>If <span class="math inline">\(y\)</span> has curvature that
changes sign, local errors can partially cancel out over the course of
the integration.</p></li>
</ul>
<p>For a more systematic treatment of integration methods and their
error properties, Chapter 16 of <em>Numerical Recipes in C</em> provides
an excellent introduction <span class="citation"
data-cites="1992nrca.book.....P">(Press et al. 1992)</span>.</p>
<p>Regardless of the method used, sanity checks are essential to
validate the result. These include:</p>
<ul>
<li><p>Trying different integration schemes.</p></li>
<li><p>Performing convergence tests to ensure the solution stabilizes as
<span class="math inline">\(\Delta t \to 0\)</span>.</p></li>
<li><p>Leveraging any known properties of the solution to verify
correctness.</p></li>
</ul>
<p>For example, we can exploit the properties of Hamiltonian systems to
design integrators. In this thesis, we implemented the Leapfrog
integrator and the Forest-Ruth scheme <span class="citation"
data-cites="bovy_inprep 1990PhyD...43..105F">(Bovy 2025a; Forest and
Ruth 1990)</span>. These schemes are derived from the structure of
Hamiltonian mechanics and are known as <em>symplectic integrators</em>.
Before continuing, I would like to quote <span class="citation"
data-cites="bovy_inprep">(Bovy 2025a)</span>:</p>
<blockquote>
<p><em>Hamiltonian integrators are often called symplectic. This name
comes from the fact that these integrators are Hamiltonian maps, whose
mathematical structure is that of a vector flow on a symplectic
manifold. Many fine dynamicists have made great contributions to the
field without delving deeply into the meaning of the previous sentence
and we do not discuss this further.</em></p>
</blockquote>
<p>However, my curiosity about linguistics pushed me to delve further:
What does <em>symplectic</em> mean? <span class="citation"
data-cites="weyl1946classical">Weyl (1946)</span> coined the term
because <em>complex</em> was already taken. The prefix Latin
<em>com</em>- refers to <em>together</em>, and <em>plexus</em> comes
from Greek meaning “woven” or “braided”. Symplectic translates exactly
the same way: <em>sym</em>- is a Greek prefix for “together.” The idea
remains the same: in Hamiltonian dynamics, the evolution of position and
momentum are interdependent. This becomes clearer in matrix form: <span
class="math display">\[\begin{bmatrix}
            \dot{\bf{q}}\\
            \dot{\bf{p}}
        \end{bmatrix}
         =
        \begin{bmatrix}
            0 &amp; I_n \\
            -I_n &amp; 0
        \end{bmatrix}
                \begin{bmatrix}
            \frac{\partial \mathcal{H}}{\partial \bf{q}} \\
            \frac{\partial \mathcal{H}}{\partial \bf{p}}
        \end{bmatrix}
        \label{eq:symplectic}\]</span> Here, the skew-symmetric
symplectic matrix “weaves” the positions and momenta together.</p>
<p>Although the equations of motion do not admit analytical solutions,
they possess several known properties. First, trajectories governed
solely by gravity are time-reversible. This property is important for
our methodology, where we integrate the equations of motion backward in
time and then forward again to the present-day position. Secondly, the
total orbital energy is conserved. Moreover, according to Liouville’s
theorem, Hamiltonian flows preserve the local phase space volume. A
corollary of this is that the determinant of the Jacobian matrix of the
transformation from <span
class="math inline">\(\left(q,p\right)\rightarrow
\left(q&#39;,p&#39;\right)\)</span> must be one, which means that the
transformation only rotates or translates an infinitesimal volume but
does not shrink or expand the volume. We can view the transform as:
<span class="math display">\[\begin{aligned}
        q&#39; &amp;= q + \frac{\partial \mathcal{H}}{\partial p}\Delta
t, \\
        p&#39; &amp;= -\frac{\partial \mathcal{H}}{\partial q}\Delta t +
p,
    
\end{aligned}\]</span> The Jacobian matrix is given by <span
class="math inline">\(\left(\frac{\partial x_i&#39;}{\partial x_j
}\right)\)</span>: <span class="math display">\[\begin{bmatrix}
            1 &amp; \Delta t \frac{\partial^2 \mathcal{H}}{\partial p^2}
\\  
            -\Delta t \frac{\partial^2 \mathcal{H}}{\partial q^2} &amp;
1 \\  
        \end{bmatrix}\]</span> and the subsequent determinant is: <span
class="math display">\[\mathrm{det}\left(J\right) = 1 - \Delta t^2
\frac{\partial^2 \mathcal{H}}{\partial q^2} \frac{\partial^2
\mathcal{H}}{\partial p^2}.\]</span> In general, neither <span
class="math inline">\(\frac{\partial^2 \mathcal{H}}{\partial
q^2}\)</span> or <span class="math inline">\(\frac{\partial^2
\mathcal{H}}{\partial p^2}\)</span> are zero. There is a quick fix to
this dilemma, namely, only stepping in <span
class="math inline">\(q\)</span> or <span
class="math inline">\(p\)</span> while holding the other constant. In
turn, the transformation of a single step will have a Jacobian whose
determinant is 1. The transformation order becomes: <span
class="math inline">\((q,p) \rightarrow (q&#39;,p) \rightarrow
(q&#39;,p&#39;)\)</span>. This is commonly referred to as a sequence of
<em>drifts</em> and <em>kicks</em>. A <em>drift</em> updates the
position while holding the momentum fixed, and a <em>kick</em> updates
the momentum while holding the position fixed. Symplectic integrators
alternate these operations in a specific sequence to preserve the
Hamiltonian and phase space volume.</p>
<p>The scheme outlined above is essentially a first-order method and is
closely related to Euler’s method. More sophisticated integrators use
values from multiple timesteps to construct higher-order estimates of
the system’s evolution. For example, some schemes temporarily evolve the
position to an intermediate value <span
class="math inline">\(q_\mathrm{temp}\)</span>, use this to compute a
momentum <span class="math inline">\(p_\mathrm{temp}\)</span>, and then
adjust both using weighted averages or predictor-corrector steps to
reach the final state. These methods carefully balance forward and
backward steps to optimize accuracy while preserving the symplectic
structure.</p>
<p>One of the most commonly used symplectic integrators in galactic
dynamics is the Leapfrog scheme. It works by interleaving updates of
positions and momenta using time-centered averages. Specifically, the
average momentum between <span class="math inline">\(q_i\)</span> and
<span class="math inline">\(q_{i+1}\)</span> (denoted <span
class="math inline">\(p_{i+1/2}\)</span>) is used to advance the
position, and then the average force (derived from the potential) is
used to update the momentum. In Cartesian coordinates—used throughout
this thesis—the Leapfrog algorithm can be written as: <span
class="math display">\[\begin{aligned}
        x_{i+1/2} &amp;= x_i + \frac{1}{2} \dot{x}_i \Delta t , \\
        \ddot{x}_{i+1/2} &amp;= -\nabla \Phi(x_{i+1/2}), \\
        \dot{x}_{i+1} &amp;= \dot{x}_i + \ddot{x}_{i+1/2} \Delta t, \\
        x_{i+1} &amp;= x_{i+1/2} + \frac{1}{2} \dot{x}_{i+1} \Delta t.
    
\end{aligned}\]</span> As will be shown in the next section, the
Leapfrog algorithm is sufficient. However, the question of computational
efficiency and numerical accuracy is ever present. Leapfrog uses the two
local points about the position and momenta to evolve them. Other
schemes can use more points to have more accurate estimations for the
local derivatives.</p>
<p><span class="citation" data-cites="1990PhyD...43..105F">Forest and
Ruth (1990)</span> proposed one such method for symplectic integration.
The method involves finding roots of high order polynomials which
determine the distances about the local point for finding the best
estimate of the derivative for evolving the system. The method involves
solving a cubic polynomial to determine the optimal coefficients. While
the derivation is mathematically involved, the final scheme is
straightforward to implement. I implemented this method and tested its
efficiency against the Leapfrog and present the results in the following
section. There are eight coefficients in this method, which are
presented in Table <a href="#tab:forest_ruth_coeffs"
data-reference-type="ref"
data-reference="tab:forest_ruth_coeffs">2</a>.</p>
<div id="tab:forest_ruth_coeffs">
<table>
<caption>Velocity (<span class="math inline">\(c_n\)</span>) and
acceleration (<span class="math inline">\(d_n\)</span>) coefficients for
the Forest-Ruth symplectic integrator.</caption>
<tbody>
<tr>
<td colspan="4" style="text-align: center;">Velocity coefficients (<span
class="math inline">\(c_n\)</span>)</td>
<td colspan="4" style="text-align: center;">Acceleration coefficients
(<span class="math inline">\(d_n\)</span>)</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(c_1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(c_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(c_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(c_4\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_4\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(w +
\frac{1}{2}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-w\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-w\)</span></td>
<td style="text-align: center;"><span class="math inline">\(w +
\frac{1}{2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2w +
1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-4w -
1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2w +
1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>The coefficients are all based on the solution to the cubic
polynomial: <span class="math inline">\(48 w^3 + 24 w^2 - 1 =
0\)</span>. For a single step, the positions and velocities are updated
as follows: <span class="math display">\[\begin{aligned}
        x&#39; &amp;= x + c_n v \Delta t \\
        t&#39; &amp;= t + c_n \Delta t \\
        \ddot{x} &amp;= \nabla \Phi (x&#39;) \\
        \dot{x}&#39; &amp;= \dot{x} + d_n \ddot{x} \Delta t,
    
\end{aligned}\]</span> where <span class="math inline">\(n\)</span> is
the <em>mini-step</em>. Notice that the sum of <span
class="math inline">\(\sum_n^4 c_n\)</span> and <span
class="math inline">\(\sum_n^4 d_n\)</span> both equal 1, which is a
full timestep <span class="math inline">\(\Delta t\)</span>.</p>
<p>Lastly, it is important to note that the Leapfrog algorithm is
symplectic and time-reversible only for Hamiltonians that are both
time-independent and separable—that is, where the Hamiltonian can be
written as a sum of a kinetic term depending only on momenta, <span
class="math inline">\(T(p)\)</span>, and whose potential depends only on
position <span class="math inline">\(\Phi(q)\)</span>. These conditions
are satisfied for systems in an inertial frame with conservative forces.
This is true when integrating the motion for the center of mass of the
globular clusters. However, the Hamiltonian for the integration of the
particles does depend on time. So the Leapfrog algorithm may introduce
systematic integration errors due to the violation of its underlying
assumptions, beyond ordinary rounding errors.</p>
<p>Similarly, when we integrate the orbits of either the particles or
the globular clusters in the Galaxy containing a bar, we are faced with
a choice: we can either work in a time-dependent inertial frame, where
the potential rotates and the Hamiltonian explicitly depends on time, or
we can transform to a rotating frame, in which case the kinetic energy
becomes position-dependent due to Coriolis and centrifugal forces, which
breaks the necessary criterion of separability: <span
class="math inline">\(\mathcal{H}(q,p) = T(p)+\Phi(q)\)</span>. In both
cases, the standard assumptions of the Leapfrog algorithm are
violated.</p>
<p>Nonetheless, we will continue to use Leapfrog as it remains a robust
and efficient integrator for a wide range of astrophysical systems. Its
good long-term energy conservation makes it a reasonable approximation
even when the ideal assumptions are not strictly met. However, this
highlights the need for careful validation: we must verify that the
integration errors remain within acceptable bounds, especially in
systems with non-separable or time-dependent dynamics. This validation
is the subject of the next section.</p>
<h1 id="numerical-error-and-computation-time">Numerical Error and
Computation Time</h1>
<p>To ensure the quality of the integration, we perform two main checks.
The first is to ensure that the initial orbital energy of a given
particle is conserved to high precision. At each timestep, the relative
error in the energy conservation is: <span
class="math display">\[\mathrm{err}(E(t)) = \left|\frac{E(t) -
E_0}{E_0}\right|,\]</span> where <span
class="math inline">\(E_0\)</span> is the initial energy and <span
class="math inline">\(E\)</span> is the orbital energy at a given
timestep <span class="math inline">\(t\)</span>. For the case of a
globular cluster, the total orbital energy is its own kinetic energy
plus its gravitational potential energy in the Galaxy: <span
class="math inline">\(E = T(\mathbf{v}_{\mathrm{GC}}) +
\Phi_{\mathrm{MW}}\left(\mathbf{x}_{\mathrm{GC}}\right)\)</span>, where
<span class="math inline">\(\mathbf{x}_{\mathrm{GC}}\)</span> and <span
class="math inline">\(\mathbf{v}_{\mathrm{GC}}\)</span> are the
Cartesian galactocentric position and velocity of the globular cluster.
For the case of the <span class="math inline">\(i\)</span>-th
star-particle within a globular cluster, the potential energy of the
cluster is included: <span class="math inline">\(E_i = T(\textbf{v}_i) +
\Phi_{\mathrm{MW}}\left(\textbf{x}_i\right) +
\Phi_\mathrm{GC}\left(\textbf{x}_i -
\textbf{x}_{\mathrm{GC}}\right)\)</span>, where <span
class="math inline">\(\mathbf{x}_i\)</span> is the position relative to
the Galactic center. The same approach holds when a bar is included, the
only difference being that the Galactic potential has a time-dependent
element.</p>
<p>For potentials with the galactic bar, the total energy is not
conserved but rather the Jacobi energy, and this is true only for the
globular clusters since we treat them as point masses. For the
star-particles, the energy is not conserved in the simulations, since
they are subject to the force from the globular cluster. However, we
track the energy particularly when we perform the second check, which is
time-reversibility.</p>
<p>To check the time-reversibility, we integrate a cluster back in time,
and then change the sign of its velocity to subsequently integrate
forward in time. If the integration is correct, the cluster should
remain on the same trajectory retracing its steps. We investigate this
for the following scenarios and show the results below:</p>
<ul>
<li><p>The globular cluster population orbiting within a static Milky
Way potential;</p></li>
<li><p>Star-particles orbiting within a stationary and isolated globular
cluster;</p></li>
<li><p>Full stream generation, i.e., star particles orbiting within a
globular cluster that orbits the Galaxy.</p></li>
</ul>
<p>At this stage, I did not have time to perform a full quality check of
orbits within the barred potential. However, I refer the reader to the
<code>tstrippy</code> documentation, where I demonstrate the
time-reversibility of cluster orbits in the barred potential. <a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<h2 id="globular-cluster-orbits-in-a-static-galaxy">Globular Cluster
Orbits in a Static Galaxy</h2>
<p>The initial conditions for the globular cluster system (positions and
velocities) were taken from <span class="citation"
data-cites="2018MNRAS.478.1520B">Baumgardt and Hilker (2018)</span>’s
online globular cluster catalog whose data derived from Gaia Early Data
Release 3 among other sources <span class="citation"
data-cites="2021MNRAS.505.5957B 2021A&amp;A...649A...1G 2021MNRAS.505.5978V 2023A&amp;A...674A...1G">(Baumgardt
and Vasiliev 2021; Gaia Collaboration et al. 2021, 2023; Vasiliev and
Baumgardt 2021)</span>.</p>
<p>To test the integrator, we integrated the whole globular cluster
system for 5 Gyr, and then integrated it back to the initial conditions.
We used four timesteps: <span
class="math inline">\(10^4,10^5,10^6,10^7\)</span> years which
corresponds to <span
class="math inline">\(\left[500,5000,50000,500000\right]\)</span>
integration steps, respectively. In general, the timestep should scale
with the dynamical time of the orbit. In other words, the timestep
should be inversely proportional to the orbital energy. The further the
system is from the galactic center, a larger timestep can be used to
obtain a given numerical error.</p>
<p>Of course, the timestep does not just simply scale with a body’s
orbital energy, it should scale with the maximum acceleration
experienced in the system. A highly eccentric orbit requires a smaller
timestep to properly integrate the motion near the pericenter, compared
to a circular orbit at the same orbital energy. To not clutter the
graph, Fig. <a href="#fig:numericalErrorLeapfrogVanilla"
data-reference-type="ref"
data-reference="fig:numericalErrorLeapfrogVanilla">1</a> only present
the whole globular cluster system twice, once integrated with the
smallest timestep, <span class="math inline">\(10^4\)</span> years, and
once with the largest timestep: <span
class="math inline">\(10^7\)</span> years.</p>
<figure id="fig:numericalErrorLeapfrogVanilla">
<img src="images/numericalErrorLeapfrogVanilla.png" />
<figcaption>Relative error in orbital energy for the whole globular
cluster system with two different timesteps, dt = <span
class="math inline">\(10^{7}\)</span> and <span
class="math inline">\(10^{4}\)</span> years. Each cluster’s is colored
by its initial orbital energy. The average of the whole system for a
given timestep is indicated with dotted and solid black lines,
respectively.</figcaption>
</figure>
<p>In Fig. <a href="#fig:numericalErrorLeapfrogVanilla"
data-reference-type="ref"
data-reference="fig:numericalErrorLeapfrogVanilla">1</a> we can notice
that orbits with higher orbital energies (in red) have low numerical
error compared to those with lower energies (in blue), which penetrate
deeper in the potential well. It is clear that, for the whole system,
<span class="math inline">\(10^7\)</span> years is a timestep that is
far too large, however, interestingly enough, for some of the farthest
globular clusters, a timestep of 10 million years resolves their orbits
to an error of <span class="math inline">\(\langle \Delta E / E_0
\rangle \sim 10^{-5}\)</span>, which is still far less than the
uncertainties due to observational uncertainties. Note that in both
cases, the errors neither accumulate nor grow with time. This is a
testament to the quality of the Leapfrog integration scheme, which is
designed to conserve the Hamiltonian accurately.</p>
<p>Fig. <a href="#fig:numericalErrorReverseIntegration"
data-reference-type="ref"
data-reference="fig:numericalErrorReverseIntegration">2</a> illustrates
the <em>time reversibility</em> of the integrator, i.e., its ability to
retrace its own steps. For each timestep, I compute the difference
between the forward integration and the backward retrace, normalizing to
the mean of the two positions. The same computation is performed for the
velocities. Specifically, I take the current kinematics of each cluster
and integrate them forward in time for five billion years, storing
positions and velocities at each step. Starting from the final state, I
then integrate backward for the same duration, again recording positions
and velocities at every step. At each corresponding time stamp <span
class="math inline">\(t_i\)</span>, I calculate the vector differences
in position and velocity, normalizing the positional error to the mean
position of the forward and backward steps.</p>
<p>The timestep of <span class="math inline">\(10^7\)</span> yr
saturates only after 2 Gyr. The distances do not continue to grow
because the orbital energy only differs by one part in ten, so at later
timesteps, the cluster is still within the same region of phase-space,
but the retrace is at a completely different location than the initial
integration. The errors in the timestep of <span
class="math inline">\(10^6\)</span> yr become significant, though by the
end of the integration period of 5 Gyr they are still only one part in
ten thousand. The timesteps of <span class="math inline">\(10^5\)</span>
and <span class="math inline">\(10^4\)</span> yr have excellent
retraceability and on average, only differ by one part in <span
class="math inline">\(10^{-14}\)</span>, and are thus only limited by
round off error from the use of double precision floating point
numbers.</p>
<figure id="fig:numericalErrorReverseIntegration">
<img src="images/numericalErrorReverseIntegration.png" />
<figcaption>The <em>time-reversibility</em> of the Leapfrog scheme for
the 165 Galactic globular cluster’s for four different timesteps
indicated in the legend. The whole system is only shown for <span
class="math inline">\(10^4\)</span> yr and <span
class="math inline">\(10^7\)</span> yr to avoid clutter. The clusters
are color-coded to their initial orbital energy just as Fig. <a
href="#fig:numericalErrorLeapfrogVanilla" data-reference-type="ref"
data-reference="fig:numericalErrorLeapfrogVanilla">1</a></figcaption>
</figure>
<p>Computation time is quite important. Fig. <a
href="#fig:numericalErrorGlobularClustersComputationTime"
data-reference-type="ref"
data-reference="fig:numericalErrorGlobularClustersComputationTime">3</a>
presents the total computation time of integrating the globular cluster
system, and the time of a single integration step, which is computed by
normalizing the total time by the number of objects and number of steps
taken: <span
class="math inline">\(T_{\mathrm{total}}/N_{\mathrm{GCs}}/N_{\mathrm{steps}}\)</span>.
In general, the relationship is linear and the integration time per step
per object is roughly constant. The downward trend presented in Fig. <a
href="#fig:numericalErrorGlobularClustersComputationTime"
data-reference-type="ref"
data-reference="fig:numericalErrorGlobularClustersComputationTime">3</a>
is in part a coincidence, as some time realizations minimize this, and
in part due to the overhead computation time with initializing and
finalizing the calculation contributes less and less with increasing
integration time. Nonetheless, for this processor (Apple M2 processor),
for a single integration step the mean time is <span
class="math inline">\(\sim\)</span> 128 nanoseconds.</p>
<figure id="fig:numericalErrorGlobularClustersComputationTime">
<img src="images/numericalErrorGlobularClustersComputationTime.png" />
<figcaption>Computation time for integrating the entire globular cluster
system using the Leapfrog scheme. The top panel shows the total time
while the bottom shows computation time for a single step, for a single
object being integrated. This was performed on a 2022 MacBook Air with
an Apple M2 processor. </figcaption>
</figure>
<p>The Ruth-Forest algorithm discussed in the previous section was
implemented and is reported in Fig. <a
href="#fig:numericalErrorRuthForest" data-reference-type="ref"
data-reference="fig:numericalErrorRuthForest">4</a>. Here, as expected,
we see that the precision greatly increases when decreasing the
timestep. However, since there are four force evaluations for a single
timestep, this method is naturally slower per step than Leapfrog. How do
the two methods compare over all?</p>
<figure id="fig:numericalErrorRuthForest">
<img src="images/numericalErrorRuthForest.png" />
<figcaption>The conservation of energy error for the Ruth-Forest
integration scheme for the globular cluster system. This plot is similar
to Fig. <a href="#fig:numericalErrorLeapfrogVanilla"
data-reference-type="ref"
data-reference="fig:numericalErrorLeapfrogVanilla">1</a>, but does not
present on the whole globular cluster system, just the average error in
energy for the whole system with a given timestep. The timestep and
time-average numerical error for the whole system is presented next to
each curve. The average computation time per integration step per single
object is as well.</figcaption>
</figure>
<p>Fig. <a href="#fig:numericalErrorMeanEnergyErrorRuthForestLeapfrog"
data-reference-type="ref"
data-reference="fig:numericalErrorMeanEnergyErrorRuthForestLeapfrog">5</a>
compares the numerical error for again the total number of steps (which
is inversely proportional to the timestep). It is clear that, for a
given step size, the Ruth-forest outperforms the Leapfrog, but is it
actually better? To answer this question, I fit the two curves with
their own trend lines to find the number of steps required to have a
relative error of <span class="math inline">\(10^{-8}\)</span>. With
this requirement, The Leapfrog scheme requires 262,641 steps while the
Ruth-Forest scheme requires 102,773 steps. However, given the difference
in computation time per step, on average, the Forest-Ruth scheme takes
<span class="math inline">\(\sim 1.5\)</span>x more time for the same
degree of numerical precision than the Leapfrog. For this reason, we use
the Leapfrog algorithm. In this problem, numerical uncertainties are
must less of a limiting factor compared to modeling uncertainties and
observational uncertainties, so a better integrator for numerical
precision is not worth the pay off of longer computation times.</p>
<figure id="fig:numericalErrorMeanEnergyErrorRuthForestLeapfrog">
<img src="images/numericalErrorMeanEnergyErrorRuthForestLeapfrog.png" />
<figcaption>The time averaged error in the conservation of energy for
the entire globular cluster system for four different timesteps, for two
different integration techniques: the Leapfrog against the Ruth-Forest.
Their respective trend lines are shown.</figcaption>
</figure>
<h2 id="star-particles-in-a-static-globular-cluster">Star-particles in a
static globular cluster</h2>
  <div class="video-container">
    <video controls style="max-width: 100%;">
      <source src="videos/cluster_showing_scale_and_dynamical_time.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>
  </div>
<p>A classic challenge in astronomy and the physical sciences arises
when a problem involves two or more physical processes that operate on
very different time scales. This is certainly the case when studying
globular clusters. Figure <a href="#fig:GCsystemCharacteristicTimes"
data-reference-type="ref"
data-reference="fig:GCsystemCharacteristicTimes">6</a> illustrates the
orders-of-magnitude differences in time scales both across the globular
cluster population and within individual clusters.</p>
<figure id="fig:GCsystemCharacteristicTimes">
<img src="images/GCsystemCharacteristicTimes.png" />
<figcaption>The top panel shows orbital characteristic times of the
globular cluster system, while the bottom panel shows internal
characteristic times for three selected clusters. <em>Top</em>: The red
distribution shows the orbital crossing time of each cluster within the
Galaxy, while the blue distribution shows a characteristic internal
dynamical time. <em>Bottom</em>: The distribution of crossing times for
1,000 sampled star particles within the globular clusters with the
smallest, median, and largest internal dynamical times. The vertical
dashed lines mark the characteristic internal dynamical
times.</figcaption>
</figure>
<p>A useful metric for characterizing a system’s time scale is the
<em>crossing time</em>, which is the time it would take a star to reach
the center of the system given its current speed: <span
class="math display">\[t_\mathrm{cross} = \frac{r}{v}.\]</span> While
this quantity is not an integral of motion and varies as a star moves,
it still provides a convenient and informative estimate of the dynamical
time scale. It breaks down in extreme cases, such as a purely radial
orbit near pericenter or apocenter where the instantaneous velocity
approaches zero, but such cases are rare and do not undermine its
utility. We compute the crossing time for each globular cluster in the
galaxy (red distribution in the top panel of Fig. <a
href="#fig:GCsystemCharacteristicTimes" data-reference-type="ref"
data-reference="fig:GCsystemCharacteristicTimes">6</a>) as well as for
each individual star particle within the clusters.</p>
<p>For the cluster as a whole, a robust characteristic dynamical time
can be defined as: <span class="math display">\[\tau =
\sqrt{\frac{a^3}{GM}},\]</span> where <span
class="math inline">\(a\)</span> is a characteristic size of the system.
This is often taken to be the half-mass radius. In this work, I adopt
the half-mass radius rather than the Plummer scale radius, though the
two are related by <span class="math inline">\(r_{\mathrm{1/2}} \approx
1.3a\)</span>. This time scale was computed for each cluster and is
shown as the blue distribution in the top panel of Fig. <a
href="#fig:GCsystemCharacteristicTimes" data-reference-type="ref"
data-reference="fig:GCsystemCharacteristicTimes">6</a>.</p>
<p>Note that the distribution of cluster dynamical times has a long tail
toward longer values, overlapping with the galactic crossing times. A
natural question arises: could any cluster have a longer internal
dynamical time than its orbital crossing time? The answer should be
<em>no</em>. If it takes longer for stars to orbit within the cluster
than for the entire cluster to orbit the Galaxy, the cluster is
effectively unbound or fully disrupted. I examined this question for the
Galactic globular cluster population, and the results are shown in
Fig. <a href="#fig:GCsystemStabilityDynamicalTimeRatios"
data-reference-type="ref"
data-reference="fig:GCsystemStabilityDynamicalTimeRatios">7</a>. As
expected, all clusters have internal dynamical times shorter than their
orbital crossing times.</p>
<p>Interestingly, the ratio of these two time scales serves as a useful
diagnostic of cluster stability. Clusters in which stars complete
hundreds or thousands of internal orbits per galactic orbit are
significantly more stable than those where stars complete only a
few.</p>
<figure id="fig:GCsystemStabilityDynamicalTimeRatios">
<img src="images/GCsystemStabilityDynamicalTimeRatios.png" />
<figcaption>Ratio of each globular cluster’s galactic crossing time to
its internal dynamical time (as shown individually in the top panel of
Fig. <a href="#fig:GCsystemCharacteristicTimes"
data-reference-type="ref"
data-reference="fig:GCsystemCharacteristicTimes">6</a>). Clusters whose
internal dynamical times approach their galactic crossing times are near
disruption. In contrast, denser clusters with much shorter internal
times are more stable. The vertical bars indicate selected thresholds.
Both lists rank clusters by increasing stability, with Gran 1 being the
least stable and NGC 6229 the most.</figcaption>
</figure>
<p>To properly compute the orbits of the star particles, the timestep
must be small enough to resolve the orbit accurately while the star is
inside the cluster. How should we choose this timestep? There are two
criteria. The first is that the timestep should be some fraction of the
cluster’s dynamical time: <span class="math display">\[\Delta t&#39; =
\alpha &#39; \tau.\]</span> I use a prime to indicate that this is a
trial timestep, since the second criterion must also be satisfied: the
total number of timesteps should be an integer, <span
class="math display">\[N = \left\lceil \frac{T}{\alpha&#39; \tau}
\right\rceil,\]</span> where <span class="math inline">\(T\)</span> is
the total integration time. We round <span
class="math inline">\(N\)</span> up to ensure a slightly smaller
timestep, which becomes <span class="math inline">\(\Delta t =
T/N\)</span>. This also redefines the effective timestep fraction as
<span class="math inline">\(\alpha = \Delta t / \tau\)</span>.</p>
<p>In the experiments presented in this section, I choose several
fractions of each cluster’s dynamical time and examine the resulting
numerical errors. To efficiently explore a wide range of <span
class="math inline">\(\alpha\)</span>, I begin with a few trial values
of <span class="math inline">\(\alpha&#39;\)</span> and then round the
number of steps down so that <span class="math inline">\(N\)</span> is
not only an integer, but also a power of two. This leads to the
following condition: <span class="math display">\[N = 2^{k-1}\]</span>
where <span class="math inline">\(k \in \mathbb{N}\)</span> is an
integer index. The expression for <span class="math inline">\(k\)</span>
becomes: <span class="math display">\[k = \left\lceil
\log_2\left(\frac{T}{\alpha &#39;  \tau_\mathrm{dyn}}\right) +
1  \right\rceil.
            \label{eq:binary_time_step_criterion}\]</span></p>
<p>The goal is now to determine the appropriate value of <span
class="math inline">\(\alpha\)</span> to ensure energy conservation and
time-reversibility. In the analysis presented in the previous sections,
I selected timesteps without explicitly relating them to the crossing
times of globular cluster orbits. Fig. <a
href="#fig:numericalErrorLeapfrogVanilla" data-reference-type="ref"
data-reference="fig:numericalErrorLeapfrogVanilla">1</a> shows that a
timestep of <span class="math inline">\(\Delta t =
10^4~\mathrm{yr}\)</span> achieves a mean relative energy error of <span
class="math inline">\(10^{-8}\)</span>. Meanwhile, Fig. <a
href="#fig:numericalErrorReverseIntegration" data-reference-type="ref"
data-reference="fig:numericalErrorReverseIntegration">2</a> shows that a
timestep of <span class="math inline">\(\Delta t =
10^5~\mathrm{yr}\)</span> already achieves convergence in
time-reversibility. Comparing these values to the typical crossing time
shown in Fig. <a href="#fig:GCsystemCharacteristicTimes"
data-reference-type="ref"
data-reference="fig:GCsystemCharacteristicTimes">6</a>, we find that
they correspond to <span class="math inline">\(\alpha\)</span> values of
approximately <span class="math inline">\(2 \times 10^{-4}\)</span> and
<span class="math inline">\(2 \times 10^{-3}\)</span>, respectively.</p>
<p>In Fig. <a href="#fig:numericalErrorStaticPlummerSphereEnergyError"
data-reference-type="ref"
data-reference="fig:numericalErrorStaticPlummerSphereEnergyError">8</a>,
I investigate energy conservation in a static Plummer sphere using trial
values of <span class="math inline">\(\alpha \in [10^{-4}, 10^{-3},
10^{-2}, 10^{-1}, 1, 2]\)</span>. This experiment shows that values of
<span class="math inline">\(\alpha &lt; 10^{-2}\)</span> yield excellent
energy conservation. In this section, we do not consider the
time-reversibility as the previous section has shown the integration’s
robustness with regard to this metric. However, this is our main metric
for the next section.</p>
<figure id="fig:numericalErrorStaticPlummerSphereEnergyError">
<img src="images/numericalErrorStaticPlummerSphereEnergyError.png" />
<figcaption>Relative orbital energy for an isolated Plummer sphere
evolved with different timesteps. Each model contains the same number of
particles, <span class="math inline">\(N_p\)</span>, and is integrated
for the same duration, <span class="math inline">\(T\)</span>, as
indicated on the plot. The x-axis shows the timestep size <span
class="math inline">\(\alpha\)</span>, defined as a fraction of the
internal dynamical time <span class="math inline">\(\tau = \sqrt{a^3 /
GM}\)</span>.</figcaption>
</figure>
<h2 id="full-stream-generation">Full stream generation</h2>
<p>The preceding sections assessed the numerical stability of
integrating globular cluster orbits within the Milky Way, focusing on
time-reversibility and relative energy error across two integration
schemes: Leapfrog and Forest-Ruth. I also considered the computational
cost associated with different temporal resolutions. Separately, I
evaluated the energy conservation for star particles evolving within a
stationary Plummer sphere, quantifying the relative error as a function
of timestep. In that context, the cluster’s potential was scaled to its
scale radius, mass, and the gravitational constant. This
non-dimensionalization allowed me to select timesteps as fractions of
the internal dynamical time <span class="math inline">\(\tau\)</span> of
each cluster.</p>
<p>In this section, I combine them: I examine the quality of orbit
integration for star particles evolving within a globular cluster, which
in turn is orbiting in the Galactic potential.</p>
<p>I restrict the analysis here to the Leapfrog integrator for two main
reasons. First, although the Forest-Ruth scheme achieves better energy
conservation (see Fig. <a
href="#fig:numericalErrorMeanEnergyErrorRuthForestLeapfrog"
data-reference-type="ref"
data-reference="fig:numericalErrorMeanEnergyErrorRuthForestLeapfrog">5</a>),
this comes at a significantly higher computational cost, which outweighs
its marginal gains for this application. Second, the equations of motion
used to model stream generation require loading the position of the host
cluster for each force computation. Because Forest-Ruth evaluates forces
at non-uniform substeps, using it would require either: (1) storing and
loading the cluster orbit at each substep, which would demand excessive
disk space and complex code restructuring; or (2) interpolating the
orbit at intermediate times, which introduces ambiguity regarding
whether time-reversibility is preserved with linear or cubic
interpolation. For these reasons, I opted not to explore Forest-Ruth
further in the context of full stream generation.</p>
<p>To assess the performance of the stream-generation method, I designed
a quality assurance experiment, illustrated in Fig. <a
href="#fig:NumericalErrorStreamRetrace_NGC6171"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171">9</a>. I began
by integrating the orbit of a globular cluster’s center of mass backward
in time by 1 Gyr. At that point, I initialized a Plummer sphere with 512
star particles using the cluster’s half-mass radius and total mass. This
system was translated to the center-of-mass phase-space coordinates and
then integrated forward to the present day, forming a stream. I recorded
the resulting positions and computation time. To test
time-reversibility, I subsequently integrated the stream particles
backward again for 1 Gyr.</p>
<p>A note on terminology: although the cluster orbit is initialized from
present-day observations, in the context of stream generation, I refer
to the past position (1 Gyr ago) as the “initial conditions”. The
forward-integrated system represents the “stream”, and the
backward-integrated version of the stream is referred to as the
“retrace”.</p>
<p>Fig. <a href="#fig:NumericalErrorStreamRetrace_NGC6171"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171">9</a> shows the
results for four different timesteps. As expected, increasing the
timestep degrades time-reversibility. For the largest timestep (<span
class="math inline">\(\alpha \approx 1\)</span>, top left), the retrace
fails to recover the original configuration. The retraced structure
remains a stream and does not re-coalesce into a cluster. The results
improve rapidly with decreasing timestep: at <span
class="math inline">\(\alpha \approx 2 \times 10^{-1}\)</span>, most
particles return close to their starting positions with only slight
offsets. At <span class="math inline">\(\alpha \approx 2 \times
10^{-2}\)</span>, nearly all particles recover their initial conditions,
and by <span class="math inline">\(\alpha \approx 6 \times
10^{-3}\)</span>, the retrace is nearly perfect.</p>
<figure id="fig:NumericalErrorStreamRetrace_NGC6171">
<img src="images/NumericalErrorStreamRetrace_NGC6171.png" />
<figcaption>Time-reversibility test for NGC 6171. The cluster’s orbit
was integrated backward by 1 Gyr, and a Plummer sphere of 512 particles
was initialized at that position (“Initial”). The system was then
integrated forward (“Stream”) and backward again (“Retrace”). Each panel
shows a different timestep, which was selected as a fraction of the
internal dynamical time <span class="math inline">\(\tau\)</span>. The
sub-panels zoom in on the cluster core, comparing the initial and
retraced positions. Accuracy improves from top to bottom as the timestep
decreases.</figcaption>
</figure>
<p>Fig. <a href="#fig:NumericalErrorStreamRetrace_EnergyErrors"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_EnergyErrors">10</a>
presents the integrator’s energy conservation performance during the
retrace phase of Fig. <a href="#fig:NumericalErrorStreamRetrace_NGC6171"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171">9</a>, across
the same timesteps.</p>
<figure id="fig:NumericalErrorStreamRetrace_EnergyErrors">
<img src="images/NumericalErrorStreamRetrace_EnergyErrors.png" />
<figcaption>Relative error in energy conservation during the retrace. As
expected, accuracy improves with decreasing timestep. The
<em>stream</em> distribution shows the final energy of each particle
relative to its initial energy and <em>not</em> the quality of the
integration. This reflects the spread in orbital energies imparted
during initial sampling. At large timesteps, the retrace energy
distribution approaches that of the stream.</figcaption>
</figure>
<p>Although the retrace fails for the largest timestep in Fig. <a
href="#fig:NumericalErrorStreamRetrace_NGC6171"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171">9</a>, Fig. <a
href="#fig:NumericalErrorStreamRetrace_EnergyErrors"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_EnergyErrors">10</a>
shows that the relative energy error remains modest—between <span
class="math inline">\(10^{-4}\)</span> and <span
class="math inline">\(10^{-2}\)</span>. However, this metric requires
careful interpretation. What appears as an “error” primarily reflects
the intrinsic spread in orbital energies among star particles, relative
to the center-of-mass energy.</p>
<p>We can estimate this ratio by comparing the internal potential energy
scale of the cluster to its orbital energy in the Galaxy. The cluster’s
characteristic potential is roughly <span class="math inline">\(\Phi
\sim GM/a\)</span>, with <span class="math inline">\(M \sim
10^5~M_\odot\)</span> and <span class="math inline">\(a \sim
0.005\)</span> kpc, giving <span class="math inline">\(\Phi \sim
10^2~\mathrm{km}^2\,\mathrm{s}^{-2}\)</span>. Meanwhile, the typical
orbital energy of a globular cluster is around <span
class="math inline">\(10^5~\mathrm{km}^2\,\mathrm{s}^{-2}\)</span>.</p>
<p>This three-order-of-magnitude difference implies that the intrinsic
energy spread from the Plummer sampling is about <span
class="math inline">\(10^{-3}\)</span> of the total orbital energy,
which is consistent with the the apparent energy “error” in the stream
of Fig. <a href="#fig:NumericalErrorStreamRetrace_EnergyErrors"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_EnergyErrors">10</a>.
Thus, this differences does not arise from numerical drift, but from the
physical energy distribution encoded in the initial conditions.</p>
<p>Fig. <a href="#fig:NumericalErrorStreamRetrace_NGC6171"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171">9</a> &amp;
Fig. <a href="#fig:NumericalErrorStreamRetrace_EnergyErrors"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_EnergyErrors">10</a>
demonstrate the case of a single cluster. How is the energy conservation
for the entire catalog? Fig. <a
href="#fig:NumericalErrorStreamRetraceEnergyConservation"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetraceEnergyConservation">11</a>
presents the relative error in the conservation of energy for retracing
the orbit of each individual star particle per globular cluster for each
cluster in the catalog. Each data point reports the mean error in the
conservation of energy. Each cluster was integrated for 5 Gyr. The upper
limits for the timesteps were sampled logarithmically between <span
class="math inline">\(10^{0}\)</span> and <span
class="math inline">\(10^{-2}\)</span>, the exact timesteps are based on
the criterion from Eq. <a href="#eq:binary_time_step_criterion"
data-reference-type="ref"
data-reference="eq:binary_time_step_criterion">[eq:binary_time_step_criterion]</a>.</p>
<figure id="fig:NumericalErrorStreamRetraceEnergyConservation">
<img src="images/NumericalErrorStreamRetraceEnergyConservation.png" />
<figcaption>The conservation of energy for the retrace of each globular
cluster in the catalog. Each cluster was sampled with 512 particles and
integrated for 5 Gyr. Four upper thresholds for each timestep were
logarithmically sampled between <span
class="math inline">\(10^{0}\)</span> and <span
class="math inline">\(10^{-2}\)</span>, and selected individually for
each cluster in combination with it’s internal dynamical time that
evenly divided the integration time. </figcaption>
</figure>
<p>The quality of the solutions is fundamental for proper results.
However, computation time and cost is also very important. The main
motivation in using the restricted three body problem was to save
computation time. With N body, the computation time should scale with
<span class="math inline">\(N_p^2\)</span>, while for the restricted
three body problem it should scale with <span
class="math inline">\(N_p\)</span>. For both, it should scale linearly
with the number of integration steps.</p>
<p>How does <code>tstrippy</code> perform? Fig. <a
href="#fig:NumericalErrorComputationTimeScalingForStreams"
data-reference-type="ref"
data-reference="fig:NumericalErrorComputationTimeScalingForStreams">12</a>
presents the results from an experiment with all the globular clusters,
integrating them each for 1 Gyr. I choose the timestep to be at most
1/20 of each internal dynamical time, thus since each cluster has a
different dynamical time, it will require a different number of steps.
For each of these tests I use <span
class="math inline">\(10^1,~10^2,~10^2,~10^3\)</span> particles and
launched them on cluster at the Paris observatory. Then, I fit a scaling
law of <span class="math inline">\(C(N_p,N_s) = \langle C\rangle N_p^a
N_s^b\)</span>. If the code scales linearly, then each exponent, <span
class="math inline">\(a,~b\)</span>, should be 1 and <span
class="math inline">\(\langle C\rangle\)</span> would be the mean
computation time.</p>
<p>Fig <a href="#fig:NumericalErrorComputationTimeScalingForStreams"
data-reference-type="ref"
data-reference="fig:NumericalErrorComputationTimeScalingForStreams">12</a>
shows that the code is <em>less</em> efficient than linear scaling with
number of particles, since the best fit exponent is <span
class="math inline">\(1.35\)</span>. However, it scales <em>better</em>
than linear with the number of steps. Perhaps this can be explained by
the fact that there is overhead time involved for initiating and ending
each simulation. As the number of steps increases the fixed overhead
proportionally takes up less of the total time. Since the power law has
an exponent of <span class="math inline">\(0.95\)</span>, the overhead
is marginal. However, it is fortunate that the exponent is not greater
than 1, which would mean the code would slow down with execution
time.</p>
<figure id="fig:NumericalErrorComputationTimeScalingForStreams">
<img src="images/NumericalErrorComputationTimeScalingForStreams.png" />
<figcaption>How the computation scale time scales with the number of
particles and the number of steps taken.</figcaption>
</figure>
<p>Putting Fig. <a
href="#fig:NumericalErrorStreamRetraceEnergyConservation"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetraceEnergyConservation">11</a>
and Fig. <a href="#fig:NumericalErrorComputationTimeScalingForStreams"
data-reference-type="ref"
data-reference="fig:NumericalErrorComputationTimeScalingForStreams">12</a>
together, we may estimate for how long it completes to run these
simulations. If we want all simulations to have error better relative
error on the retraced conservation of energy than about 10<span
class="math inline">\(^{-3}\)</span>, then we must pick timesteps that
are smaller than about 1/20 of the dynamical time. With this criteria
selected, we can compute the number of timesteps necessary for each
globular cluster, which is a function of its internal dynamical time. By
doing so, I find that the fastest cluster can be computed in <span
class="math inline">\(\sim\)</span> 30 minutes. The median computation
time is <span class="math inline">\(\sim\)</span>17 hours. The largest
computation time was <span class="math inline">\(\sim\)</span> 5 days.
The total CPU time for the whole catalog is <span
class="math inline">\(\sim\)</span> 194 days.</p>
<h3 id="a-note-on-non-symplectic-integration">A note on non-symplectic
integration</h3>
<p>During the writing of this thesis, I discovered a bug in my code that
affected the integration scheme. Specifically, the error concerned the
way I handled the host orbit during the integration of the star
particles. In earlier implementations, I would integrate the orbit of
the host using the same timestep that I used later to integrate the
orbits of the star particles. However, this approach violated the
structure of the Leapfrog integration scheme.</p>
<p>In Hamiltonian integration, it is essential that the drift and kick
steps alternate in a consistent manner. Since I implemented a
<em>drift</em>-<em>kick</em>-<em>drift</em> (DKD) scheme, the kicks
occur at the midpoint of each timestep, meaning that forces should be
evaluated at intermediate positions. Previously, I erroneously computed
the relative position vector as <span class="math display">\[\Delta
\vec{r}_i = \vec{r}_{p,i+1/2} - \vec{r}_\mathrm{GC,i},\]</span> instead
of the correct expression: <span class="math display">\[\Delta \vec{r}_i
= \vec{r}_{p,i+1/2} - \vec{r}_\mathrm{GC,i+1/2}.\]</span></p>
<p>This mistake appeared in both <span class="citation"
data-cites="2023A&amp;A...673A..44F">Ferrone et al. (2023)</span> and
<span class="citation" data-cites="2025A&amp;A...699A.289F">Ferrone et
al. (2025)</span>. Does this invalidate our results? To assess the
impact, we can compare Figs. <a
href="#fig:NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420">13</a>
and <a href="#fig:NumericalErrorStreamRetrace_EnergyErrors"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_EnergyErrors">10</a>. In
Fig. <a
href="#fig:NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420">13</a>,
the same retracing experiment was performed, but using the flawed
integration: the host orbit was only provided at the same grid points as
the stream. In the left panel, we see that the globular cluster does not
perfectly re-coalesce when integrating backward in time, but the result
is not catastrophic. Physically, we do not expect this process to be
perfectly time-reversible; however, such irreversibility should ideally
arise from physical modeling, not from numerical artifacts.</p>
<p>We also observe that the distribution of the relative error in energy
conservation is nearly identical between the retraced and the original
stream. In any case, once the stars move beyond the Jacobi radius, their
dynamics are dominated by the galactic potential. Since this potential
was integrated correctly and symplectically, the orbits of stars outside
the cluster remain reliable and physically meaningful.</p>
<figure
id="fig:NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420">
<img
src="images/NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420.png" />
<figcaption>An illustration of how an incorrect integration scheme
breaks time reversibility. The center of mass of Palomar 5 was
integrated backward in time by 1 <span
class="math inline">\(\mathrm{s}~\frac{\mathrm{kpc}}{\mathrm{km}}\)</span>.
A Plummer sphere with 464 particles was sampled around this position
(labeled “Initial”), then integrated forward to produce the “Stream.”
The right panel shows the distribution of relative energy error. The
stream was then integrated backward in time by the same amount,
resulting in the “Retrace” configuration. The timestep was chosen as a
fraction of the internal dynamical time scale, <span
class="math inline">\(\tau\)</span>.</figcaption>
</figure>
<p>As a result of this discovery, I updated the <code>tstrippy</code>
code to warn users if the host orbit is not sampled at <span
class="math inline">\(2N + 1\)</span> points, where <span
class="math inline">\(N\)</span> is the number of integration steps.
While the flawed implementation breaks strict symplecticity for the
internal cluster dynamics, the Leapfrog integration for the globular
cluster orbits was still used correctly. This ensures that the cluster
center of mass returns to its present-day sky position and that stars
outside the cluster follow accurate galactic orbits. Ultimately, the
simplification of using a static Plummer sphere—whose mass and size
remain fixed—is a greater limitation than this particular numerical
error.</p>
<p>Lastly, I discovered this error while writing about the Forest-Ruth
integration method. To implement this scheme correctly, I would need to
know the position of the globular cluster’s center of mass at four
intermediate points across two timesteps, with the spacing determined by
the coefficients in Table <a href="#tab:forest_ruth_coeffs"
data-reference-type="ref" data-reference="tab:forest_ruth_coeffs">2</a>.
This would require either storing additional mini-time-step data or
interpolating the globular cluster’s trajectory between saved snapshots.
Both options would necessitate a substantial refactoring of the code or
an impractical increase in memory usage per orbit. Given the results
shown in Fig. <a
href="#fig:numericalErrorMeanEnergyErrorRuthForestLeapfrog"
data-reference-type="ref"
data-reference="fig:numericalErrorMeanEnergyErrorRuthForestLeapfrog">5</a>,
the gain in accuracy does not justify the computational cost.</p>
<h1 id="tstrippy">Tstrippy</h1>
<p>This project is built on <code>f2py</code>, which allows integration
between Fortran and Python. The core motivation behind this choice is
performance: Fortran, as a compiled language, provides significantly
faster execution for numerically intensive tasks, while
Python—especially within Jupyter notebooks—offers a convenient
environment for development, experimentation, and visualization.
<code>F2py</code> stands for <em>Fortran to Python</em> <span
class="citation" data-cites="peterson2009f2py">(Peterson 2009)</span>,
and it is included as a module within NumPy <span class="citation"
data-cites="numpy_f2py_manual 2020Natur.585..357H">(NumPy Developers
2025; Harris et al. 2020)</span>. The name of the project,
<code>tstrippy</code>, stands for <code>T</code>idal
<code>Strip</code>ping in <code>Py</code>thon.</p>
<p><code>F2py</code> supports Fortran 77, 90, and 95 standards, so we
chose to write the code in Fortran 90 to make use of <em>modules</em>.
In Fortran, a module encapsulates data and subroutines in a manner
somewhat analogous to classes in object-oriented programming. However,
Fortran modules do not support inheritance, and only a single instance
of a module can exist at a time—unlike classes, which can be
instantiated multiple times.</p>
<p><code>Tstrippy</code> package is structured around five core Fortran
modules, each responsible for a distinct aspect of the simulation:</p>
<ul>
<li><p><code>integrator</code>: This is the central module of the code.
It stores particle positions and velocities, computes forces, and
evolves the system forward in time. It also handles the writing of
output data at specified intervals and interfaces with all other modules
in the code.</p></li>
<li><p><code>potentials</code>: This module defines the analytical
potentials used to compute gravitational forces. It currently supports
several models, including <code>Plummer</code>, <code>Hernquist</code>,
<code>AllenSantillian</code>, <code>MiyamotoNagai</code>, the bar model
<code>LongMuraliBar</code> from <span class="citation"
data-cites="1992ApJ...397...44L">Long and Murali (1992)</span>, and the
composite model from <code>pouliasis2017pii</code> <span
class="citation" data-cites="2017A&amp;A...598A..66P">(Pouliasis, Di
Matteo, and Haywood 2017)</span>. This module can also be called in
Python, allowing users to call potential functions directly, e.g., for
computing energies during post-processing.</p></li>
<li><p><code>hostperturber</code>: This module handles the host globular
cluster. It stores its orbit (i.e., timestamps, positions, and
velocities) and ensures its synchronization with the simulation’s
internal clock. It computes the gravitational influence of the host
cluster on each star particle. This is an internal module only.</p></li>
<li><p><code>perturbers</code>: Similar in function to
<code>hostperturber</code>, this module supports additional perturbing
clusters. It allows for the inclusion of multiple perturbers and
computes their collective force on each particle. If object-oriented
programming were available in Fortran, both this module and
<code>hostperturber</code> would naturally inherit from a shared parent
class. This module only uses the positions, masses, and characteristic
radii of the other perturbers. The velocities are not imported.</p></li>
<li><p><code>galacticbar</code>: This module stores parameters for the
bar, including the polynomial coefficients for its angular displacement
as a function of time: <span class="math display">\[\theta(t) = \theta_0
+ \omega t + \dot{\omega} t^2 + \ddot{\omega} t^3 + \dots\]</span> If a
user wants a bar with a constant rotation speed, then they may pass two
coefficients. If they want a bar that accelerates for decelerates, they
may mass more coefficients for the higher order terms. The module
performs transformations into the rotating bar frame, computes the
forces in that frame, and then transforms the forces back to the
Galactocentric reference frame.</p></li>
</ul>
<p>This modular structure makes it straightforward to extend the code by
adding new physics in the form of additional modules.</p>
<p>To make the package installable and easy to distribute, I initially
followed the guide by <span class="citation"
data-cites="pythonpackagingguide">Bovy (2025b)</span>, which describes
how to create a Python package using <code>setuptools</code>—the
standard build system in the Python ecosystem. However, compatibility
between <code>setuptools</code> and <code>f2py</code> was broken
starting with NumPy <span class="math inline">\(&gt;\)</span> 1.22
(released June 22, 2022<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>) and Python <span
class="math inline">\(&gt;\)</span> 3.9.18 (released June 24, 2024<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>). This meant that Fortran extensions
could only be compiled using deprecated versions of both. These older
versions of NumPy were also not compatible with Apple’s ARM-based M1 and
M2 processors, rendering the code unusable on modern Mac systems.</p>
<p>This limitation stemmed from the deprecation and eventual removal of
<code>numpy.distutils</code>, the tool that previously enabled seamless
integration of Fortran code in NumPy-based packages. As of NumPy 1.23
and later, <code>numpy.distutils</code> was deprecated, and with
NumPy 2.0, it was removed entirely. The NumPy developers recommended
migrating to <code>meson</code> <span class="citation"
data-cites="meson_manual">(Meson Developers 2025)</span> or
<code>Cmake</code>.</p>
<p>To address these issues, I migrated the build process to
<code>meson</code>, a language-agnostic build system capable of
compiling Fortran, C, and Python extensions across architectures. This
eliminated compatibility problems and made the build process
architecture-independent. The build system now automatically detects the
system architecture and compiles accordingly.</p>
<p>The code is fully open source and available on GitHub.<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> To
support users, I created documentation hosted on
<code>readthedocs.io</code><a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a>, which includes working
examples and basic usage guides. A minimal test suite, written using
<code>pytest</code>, is also included. While not exhaustive, the tests
ensure that core functionality remains intact as the code evolves. In
the next section, I present a minimal example of how the user may use
the code within a python script.</p>
<h2 id="minimum-example">Minimum example</h2>
<p>If the package is properly installed on the system, it can be
imported at the top of any Python script:</p>
<p>Next, the user must load or define the initial conditions. The code
provides:</p>
<ul>
<li><p>The masses, sizes, and kinematics of the globular cluster catalog
from <span class="citation" data-cites="2018MNRAS.478.1520B">Baumgardt
and Hilker (2018)</span>;</p></li>
<li><p>The galactic potential parameters for model II of <span
class="citation" data-cites="2017A&amp;A...598A..66P">Pouliasis, Di
Matteo, and Haywood (2017)</span>; and</p></li>
<li><p>A galactic reference frame.</p></li>
</ul>
<p>The user must then select the system to integrate. For example, to
integrate the orbits of observed globular clusters, one must convert the
ICRS coordinates to a Galactocentric frame using <code>astropy</code>
and the provided MW reference frame. Alternatively, to simulate a star
cluster, one can generate a Plummer sphere:</p>
<p>Here, <code>NP</code> is the number of particles,
<code>halfmassradius</code> is the system’s half-mass radius,
<code>massHost</code> is the total mass of the Plummer sphere, and
<code>G</code> is the gravitational constant. All values must be in the
same unit system.</p>
<p>The integrator must then be initialized. All parameters are passed
via lists that are unpacked at the function call. Here is an example of
initializing the integrator for a stellar stream in a potential that
includes a rotating bar:</p>
<ul>
<li><p><code>setstaticgalaxy</code> specifies the static potential model
and passes its parameters.</p></li>
<li><p><code>setinitialkinematics</code> provides the initial positions
and velocities of the particles.</p></li>
<li><p><code>setintegrationparameters</code> defines the initial time,
timestep, and number of steps.</p></li>
<li><p><code>inithostperturber</code> specifies the globular cluster’s
trajectory and mass as a function of time.</p></li>
<li><p><code>initgalacticbar</code> defines a rotating bar. It takes the
name of the bar model, potential parameters, and spin
parameters.</p></li>
<li><p><code>setbackwardorbit</code> reverses the velocity vectors and
sets the internal clock to count down: <span class="math inline">\(t_i =
t_0 - i \cdot \Delta t\)</span>. For the usecase presented in this work,
<code>setbackwardorbit</code> is used for computing the globular cluster
orbits and not for the star-particles.</p></li>
</ul>
<p>The user can choose between two output modes during integration:</p>
<p>Conceptually, these represent two output paradigms:</p>
<ul>
<li><p><code>initwriteparticleorbits</code> saves the full orbit of each
particle to an individual file.</p></li>
<li><p><code>initwritestream</code> saves full snapshots of all
particles at selected timesteps.</p></li>
</ul>
<p>Both functions take:</p>
<ul>
<li><p><code>nskip</code>: number of timesteps to skip between
outputs;</p></li>
<li><p><code>myoutname</code>: the base file name;</p></li>
<li><p><code>myoutdir</code>: the output directory.</p></li>
</ul>
<p>The output files will be named like: <code>../dir/temp0.bin</code>,
<code>../dir/temp1.bin</code>, ..., up to <code>../dir/tempN.bin</code>,
where <span class="math inline">\(N = N_\mathrm{step} /
N_\mathrm{skip}\)</span>. Note that the files are written in Fortran
binary format. Although <code>scipy.io.FortranFile</code> can read them,
I use a custom parser based on <code>numpy.frombuffer</code> to avoid
the SciPy dependency. Once all parameters are set, the user can proceed
with integration using one of two methods:</p>
<h3 class="unnumbered" id="full-orbit-integration-in-memory">Full orbit
integration (in memory)</h3>
<p><code>leapfrogintime</code> stores the full orbit of each particle in
memory. This is useful for a small number of particles or short
integrations—e.g., rapid parameter studies in a notebook. However, for
large simulations it can be prohibitively memory-intensive. For
instance, integrating all globular clusters at high time resolution
might require: <span class="math display">\[7 \times N_p \times
N_\mathrm{step} \times 8~\mathrm{Byte} \approx 450~\mathrm{GB}\]</span>
if <span class="math inline">\(N_\mathrm{step} \approx 10^7\)</span>.
This will likely exceed system RAM.</p>
<h3 class="unnumbered" id="final-state-only">Final state only</h3>
<p><code>leapfrogtofinalpositions()</code> performs the integration but
only returns the final phase-space coordinates. These arrays must be
copied before deallocating memory:</p>
<p>Deallocating is necessary to avoid memory leaks or crashes in Jupyter
when rerunning code cells.</p>
<h2 id="reflection-on-developing-tstrippy">Reflection on developing
<code>tstrippy</code></h2>
<p>The earliest version of this code began as a simple Fortran script
that was interfaced to python via <code>f2py</code> and was built to
integrate test particles in specific gravitational potential models.
Since I was already familiar with Fortran and had working routines, I
chose to build on that foundation, gradually transforming the script
into a modular and more reusable package. Rather than switching to C++
or a Python-only solution, I continued using Fortran in combination with
<code>f2py</code>.</p>
<p>One of the primary motivations for writing my own code was
flexibility. When I attempted to implement a particle spray method in
<em>Galpy</em>, I found that performance degraded significantly when
using custom potentials not constructed from its internal C++ backend.
For example, I wanted to use the <code>AllenSantillian</code> halo
model, which is not natively supported. I followed the documentation and
implemented a class for it. However, custom potentials bypass
<code>Galpy</code>’s optimized C++ backend, resulting in slow
computations and rendering actions uncomputable (or at least with the
functions I tried). This pushed me to continue developing
<code>tstrippy</code>. I had a similar experience with
<code>Amuse</code>.</p>
<p>This choice, however, came with challenges. At one point, I tried
implementing potentials derived from exponential density profiles, which
do not admit closed-form solutions for the potential. I attempted to
work in elliptical coordinates, motivated by the idea that the potential
would depend only on the “distance” from the center along the
equipotential surfaces. While I successfully implemented simple
potential models in elliptical coordinates, I naively overlooked that
this changes the equations of motion entirely due to the underlying
geometry. I found that my orbits always diverged (except in special
cases). It was only later that I realized I would need to account for
the metric tensor and Christoffel symbols to properly integrate orbits
in elliptical coordinates. At that point, I chose not to pursue this
further, prioritizing scientific analysis and launching other
simulations instead. This experience helped me appreciate why many codes
and other published works prefer basis function expansions for such
problems. In hindsight, this episode was a perfect example of how even
unsuccessful attempts can lead to valuable insights. Below, I summarize
some of the key advantages and limitations I encountered while
developing a code from scratch to answer a scientific question.</p>
<h3 id="advantages-and-limitations">Advantages and Limitations</h3>
<p>Developing and maintaining this codebase brought several clear
benefits:</p>
<ul>
<li><p><em>Understanding.</em> Writing the code forced me to deeply
understand the modeling techniques involved. Otherwise, the results
would have been incorrect.</p></li>
<li><p><em>Flexibility.</em> I could implement exactly the models I
needed and extend them as required.</p></li>
<li><p><em>Transparency.</em> Results produced by my code can be
verified and reproduced by others.</p></li>
<li><p><em>Reusability.</em> Ongoing development helped me uncover and
fix subtle bugs (e.g., related to non-symplectic integrators) that do
not trigger obvious errors and only appear in edge cases or after close
inspection. Long-term engagement with the code is key to catching these
issues.</p></li>
<li><p><em>Collaboration.</em> A fellow researcher at the Paris
Observatory is now using the code. I also used it to supervise a
master’s student during their semester research project, something that
would not have been possible without building a user-friendly
tool.</p></li>
<li><p><em>Growth.</em> This project pushed me to adopt best practices:
version control, documentation, modularity. Developing my own code has
also made it easier to understand external libraries. For example, when
I implemented the King model, I studied <code>Galpy</code>’s internals
to cross-check my own method. I was delighted by how much easier it was
for me to use, despite the fact that I had not touched it within a
year.</p></li>
</ul>
<p>However, there were also drawbacks:</p>
<ul>
<li><p><em>Time cost.</em> Developing the code took time away from
direct scientific analysis. It’s possible I could have performed more
simulations or performed more analyses had I not develop my code to such
an extent.</p></li>
<li><p><em>Feature limitations.</em> My code still lacks capabilities
present in other packages: such as basis function expansions,
action-angle variable computation, or parallelization strategies using
MPI or OpenMP.</p></li>
<li><p><em>Changing relevance.</em> Scientific priorities and available
tools evolve rapidly. A general-purpose tool may become obsolete more
quickly than a single-use script written for a specific
question.</p></li>
<li><p><em>Compatibility and maintenance burden.</em> Making the code
accessible to other users also introduces challenges related to
cross-platform compatibility and dependency management. Software
environments evolve, compilers are updated, dependencies can deprecate,
and build tools change. Even with the help of modern tools like
<code>meson</code> or <code>f2py</code>, ensuring continued
compatibility requires regular testing and adaptation. As the codebase
grows, the maintenance load increases, and sustaining it as a single
developer becomes increasingly difficult, especially if the tool is made
too general.</p></li>
</ul>
<p>Nonetheless, the code was designed to address concrete scientific
questions about Milky Way stellar streams and globular clusters. In the
next two chapters, I present how this tool contributed to advancing our
understanding of the Galaxy.</p>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-2013A&amp;A...558A..33A" class="csl-entry" role="listitem">
Astropy Collaboration, Thomas P. Robitaille, Erik J. Tollerud, Perry
Greenfield, Michael Droettboom, Erik Bray, Tom Aldcroft, et al. 2013.
<span>“<span class="nocase">Astropy: A community Python package for
astronomy</span>”</span> 558 (October):A33. <a
href="https://doi.org/10.1051/0004-6361/201322068">https://doi.org/10.1051/0004-6361/201322068</a>.
</div>
<div id="ref-2018MNRAS.478.1520B" class="csl-entry" role="listitem">
Baumgardt, H., and M. Hilker. 2018. <span>“<span class="nocase">A
catalogue of masses, structural parameters, and velocity dispersion
profiles of 112 Milky Way globular clusters</span>”</span> 478 (2):
1520–57. <a
href="https://doi.org/10.1093/mnras/sty1057">https://doi.org/10.1093/mnras/sty1057</a>.
</div>
<div id="ref-2021MNRAS.505.5957B" class="csl-entry" role="listitem">
Baumgardt, H., and E. Vasiliev. 2021. <span>“<span
class="nocase">Accurate distances to Galactic globular clusters through
a combination of Gaia EDR3, HST, and literature data</span>”</span> 505
(4): 5957–77. <a
href="https://doi.org/10.1093/mnras/stab1474">https://doi.org/10.1093/mnras/stab1474</a>.
</div>
<div id="ref-2015ApJS..216...29B" class="csl-entry" role="listitem">
Bovy, Jo. 2015. <span>“<span class="nocase">galpy: A python Library for
Galactic Dynamics</span>”</span> 216 (2): 29. <a
href="https://doi.org/10.1088/0067-0049/216/2/29">https://doi.org/10.1088/0067-0049/216/2/29</a>.
</div>
<div id="ref-bovy_inprep" class="csl-entry" role="listitem">
———. 2025a. <em>Dynamics and Astrophysics of Galaxies</em>. Princeton,
NJ: Princeton University Press.
</div>
<div id="ref-pythonpackagingguide" class="csl-entry" role="listitem">
———. 2025b. <span>“Python Packaging User Guide.”</span> <a
href="https://pythonpackaging.info/"
class="uri">https://pythonpackaging.info/</a>.
</div>
<div id="ref-1914PhRv....4..345B" class="csl-entry" role="listitem">
Buckingham, E. 1914. <span>“<span class="nocase">On Physically Similar
Systems; Illustrations of the Use of Dimensional
Equations</span>.”</span> <em>Physical Review</em> 4 (4): 345–76. <a
href="https://doi.org/10.1103/PhysRev.4.345">https://doi.org/10.1103/PhysRev.4.345</a>.
</div>
<div id="ref-2023A&amp;A...673A..44F" class="csl-entry" role="listitem">
Ferrone, Salvatore, Paola Di Matteo, Alessandra Mastrobuono-Battisti,
Misha Haywood, Owain N. Snaith, Marco Montuori, Sergey Khoperskov, and
David Valls-Gabaud. 2023. <span>“<span class="nocase">The e-TidalGCs
project. Modeling the extra-tidal features generated by Galactic
globular clusters</span>”</span> 673 (May):A44. <a
href="https://doi.org/10.1051/0004-6361/202244141">https://doi.org/10.1051/0004-6361/202244141</a>.
</div>
<div id="ref-2025A&amp;A...699A.289F" class="csl-entry" role="listitem">
Ferrone, Salvatore, Marco Montuori, Paola Di Matteo, Alessandra
Mastrobuono-Battisti, Rodrigo Ibata, Paolo Bianchini, Sergey Khoperskov,
et al. 2025. <span>“<span class="nocase">Gaps in stellar streams as a
result of globular cluster flybys: The case of Palomar 5</span>”</span>
699 (July):A289. <a
href="https://doi.org/10.1051/0004-6361/202553923">https://doi.org/10.1051/0004-6361/202553923</a>.
</div>
<div id="ref-1990PhyD...43..105F" class="csl-entry" role="listitem">
Forest, Etienne, and Ronald D. Ruth. 1990. <span>“<span
class="nocase">Fourth-order symplectic integration</span>.”</span>
<em>Physica D Nonlinear Phenomena</em> 43 (1): 105–17. <a
href="https://doi.org/10.1016/0167-2789(90)90019-L">https://doi.org/10.1016/0167-2789(90)90019-L</a>.
</div>
<div id="ref-2021A&amp;A...649A...1G" class="csl-entry" role="listitem">
Gaia Collaboration, A. G. A. Brown, A. Vallenari, T. Prusti, J. H. J. de
Bruijne, C. Babusiaux, M. Biermann, et al. 2021. <span>“<span
class="nocase">Gaia Early Data Release 3. Summary of the contents and
survey properties</span>”</span> 649 (May):A1. <a
href="https://doi.org/10.1051/0004-6361/202039657">https://doi.org/10.1051/0004-6361/202039657</a>.
</div>
<div id="ref-2023A&amp;A...674A...1G" class="csl-entry" role="listitem">
Gaia Collaboration, A. Vallenari, A. G. A. Brown, T. Prusti, J. H. J. de
Bruijne, F. Arenou, C. Babusiaux, et al. 2023. <span>“<span
class="nocase">Gaia Data Release 3. Summary of the content and survey
properties</span>”</span> 674 (June):A1. <a
href="https://doi.org/10.1051/0004-6361/202243940">https://doi.org/10.1051/0004-6361/202243940</a>.
</div>
<div id="ref-2020Natur.585..357H" class="csl-entry" role="listitem">
Harris, Charles R., K. Jarrod Millman, Stéfan J. van der Walt, Ralf
Gommers, Pauli Virtanen, David Cournapeau, Eric Wieser, et al. 2020.
<span>“<span class="nocase">Array programming with NumPy</span>”</span>
585 (7825): 357–62. <a
href="https://doi.org/10.1038/s41586-020-2649-2">https://doi.org/10.1038/s41586-020-2649-2</a>.
</div>
<div id="ref-1992ApJ...397...44L" class="csl-entry" role="listitem">
Long, Kevin, and Chigurupati Murali. 1992. <span>“<span
class="nocase">Analytical Potentials for Barred Galaxies</span>”</span>
397 (September):44. <a
href="https://doi.org/10.1086/171764">https://doi.org/10.1086/171764</a>.
</div>
<div id="ref-meson_manual" class="csl-entry" role="listitem">
Meson Developers. 2025. <span>“The Meson Build System: Manual and
Reference Documentation.”</span> <a
href="https://mesonbuild.com/index.html"
class="uri">https://mesonbuild.com/index.html</a>.
</div>
<div id="ref-numpy_f2py_manual" class="csl-entry" role="listitem">
NumPy Developers. 2025. <span>“F2PY User Guide and Reference
Manual.”</span> <a href="https://numpy.org/doc/stable/f2py/"
class="uri">https://numpy.org/doc/stable/f2py/</a>.
</div>
<div id="ref-2013A&amp;A...557A..84P" class="csl-entry" role="listitem">
Pelupessy, F. I., A. van Elteren, N. de Vries, S. L. W. McMillan, N.
Drost, and S. F. Portegies Zwart. 2013. <span>“<span>The Astrophysical
Multipurpose Software Environment</span>”</span> 557 (September):A84. <a
href="https://doi.org/10.1051/0004-6361/201321252">https://doi.org/10.1051/0004-6361/201321252</a>.
</div>
<div id="ref-peterson2009f2py" class="csl-entry" role="listitem">
Peterson, Pearu. 2009. <span>“F2PY: A Tool for Connecting Fortran and
Python Programs.”</span> <em>International Journal of Computational
Science and Engineering</em> 4 (4): 296–305. <a
href="https://doi.org/10.1504/IJCSE.2009.029165">https://doi.org/10.1504/IJCSE.2009.029165</a>.
</div>
<div id="ref-2017A&amp;A...598A..66P" class="csl-entry" role="listitem">
Pouliasis, E., P. Di Matteo, and M. Haywood. 2017. <span>“<span
class="nocase">A Milky Way with a massive, centrally concentrated thick
disc: new Galactic mass models for orbit computations</span>”</span> 598
(February):A66. <a
href="https://doi.org/10.1051/0004-6361/201527346">https://doi.org/10.1051/0004-6361/201527346</a>.
</div>
<div id="ref-1992nrca.book.....P" class="csl-entry" role="listitem">
Press, William H., Saul A. Teukolsky, William T. Vetterling, and Brian
P. Flannery. 1992. <em><span class="nocase">Numerical recipes in C. The
art of scientific computing</span></em>.
</div>
<div id="ref-2017JOSS....2..388P" class="csl-entry" role="listitem">
Price-Whelan, Adrian M. 2017. <span>“<span class="nocase">Gala: A Python
package for galactic dynamics</span>.”</span> <em>The Journal of Open
Source Software</em> 2 (October):388. <a
href="https://doi.org/10.21105/joss.00388">https://doi.org/10.21105/joss.00388</a>.
</div>
<div id="ref-2018arXiv180208255V" class="csl-entry" role="listitem">
Vasiliev, Eugene. 2018. <span>“<span class="nocase">Agama reference
documentation</span>.”</span> <em>arXiv e-Prints</em>, February,
arXiv:1802.08255. <a
href="https://doi.org/10.48550/arXiv.1802.08255">https://doi.org/10.48550/arXiv.1802.08255</a>.
</div>
<div id="ref-2021MNRAS.505.5978V" class="csl-entry" role="listitem">
Vasiliev, Eugene, and Holger Baumgardt. 2021. <span>“<span
class="nocase">Gaia EDR3 view on galactic globular
clusters</span>”</span> 505 (4): 5978–6002. <a
href="https://doi.org/10.1093/mnras/stab1475">https://doi.org/10.1093/mnras/stab1475</a>.
</div>
<div id="ref-2015MNRAS.450.4070W" class="csl-entry" role="listitem">
Wang, Long, Rainer Spurzem, Sverre Aarseth, Keigo Nitadori, Peter
Berczik, M. B. N. Kouwenhoven, and Thorsten Naab. 2015. <span>“<span
class="nocase">NBODY6++GPU: ready for the gravitational million-body
problem</span>”</span> 450 (4): 4070–80. <a
href="https://doi.org/10.1093/mnras/stv817">https://doi.org/10.1093/mnras/stv817</a>.
</div>
<div id="ref-weyl1946classical" class="csl-entry" role="listitem">
Weyl, Hermann. 1946. <em>The Classical Groups: Their Invariants and
Representations</em>. Vol. 1. Princeton university press.
</div>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://tstrippy.readthedocs.io/en/latest/reverse_integrability_bar.html"
class="uri">https://tstrippy.readthedocs.io/en/latest/reverse_integrability_bar.html</a>.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://github.com/numpy/numpy/releases/tag/v1.22.0"
class="uri">https://github.com/numpy/numpy/releases/tag/v1.22.0</a><a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a href="https://www.python.org/downloads/release/"
class="uri">https://www.python.org/downloads/release/</a><a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a href="https://github.com/salvatore-ferrone/tstrippy"
class="uri">https://github.com/salvatore-ferrone/tstrippy</a><a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a href="https://tstrippy.readthedocs.io/en/latest/"
class="uri">https://tstrippy.readthedocs.io/en/latest/</a><a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
