<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Numerics</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Numerics</h1>
</header>
<p>As is oftentimes the case when aiming to model realisitic physical
systems, the equations of motion presented here do not admit closed-form
analytical solutions. As such, we must rely on numerical methods and
computer simulations to solve them. Specifically, we solve <span
class="math inline">\(N\)</span> independent sets of Hamilton’s
equations, each consisting of six first-order, coupled differential
equations.</p>
<p>Numerical integration presents several challenges. First, there is
the practical question: how do we actually solve these equations? How
can we be confident that our numerical solutions faithfully approximate
the true dynamics, especially when the true solution is unknown? How do
we handle performance, data volume, or the trade-offs between speed and
accuracy?</p>
<p>To do this, I chose to write my own code, <code>tstrippy</code>,
despite other codes on the market already existing. My motivation was
part practical: I wanted to avoid installation difficulties, steep
learning curves, and uncertainty over whether existing tools could
implement my specific setup. But above all else, I wanted to create a
reliable product that works, allows me to reproduce my results, and run
my simulations at scale.</p>
<p>This chapter documents how we solve the equations of motion
numerically, how we validate the accuracy of the solutions, and how the
code is organized under the hood.</p>
<h1 id="astronomical-units-and-scaling">Astronomical units and
scaling</h1>
<p>When writing any code, the choice of units is important. Astronomical
units are rarely the same as SI units. Their creation were often times
observationally and historically motivated, resulting in a system that
uses multiple units for the same physical quantity, which can be
confusing at first.</p>
<p>For instance, sky positions are typically reported in spherical
coordinates. Right ascension (analogous to longitude) is often expressed
in either degrees or hours, while declination (similar to latitude) is
given in degrees. Distances are reported in parsecs when derived from
parallax measurements. Line-of-sight velocities, obtained via
spectroscopic Doppler shifts, are reported in kilometers per second.
Proper motions describe angular displacements over time on the sky and
are usually reported in milliarcseconds per year. Already, we encounter
several different units for angles (degrees, hours, arcseconds), time
(years, seconds), and distance (km, kpc), none of which align with SI’s
standard units of radians, seconds, or meters, as summarized in Table <a
href="#tab:units" data-reference-type="ref"
data-reference="tab:units">1</a>.</p>
<div id="tab:units">
<table>
<caption>Units for various astronomical quantities in Galactic and SI
systems.</caption>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Distance</th>
<th style="text-align: left;">RA</th>
<th style="text-align: left;">DEC</th>
<th style="text-align: left;"><strong><span
class="math inline">\(\mathrm{v}_\mathrm{LOS}\)</span></strong></th>
<th style="text-align: left;"><span
class="math inline">\(\mu_\alpha\)</span></th>
<th style="text-align: left;"><span
class="math inline">\(\mu_\delta\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Galactic:</td>
<td style="text-align: left;"><span>[</span>kpc<span>]</span></td>
<td style="text-align: left;"><span>[</span>deg<span>]</span>
<span>[</span>HHMMSS<span>]</span></td>
<td style="text-align: left;"><span>[</span>deg<span>]</span></td>
<td style="text-align: left;">km/s</td>
<td style="text-align: left;"><span>[</span>mas/yr<span>]</span></td>
<td style="text-align: left;"><span>[</span>mas/yr<span>]</span></td>
</tr>
<tr>
<td style="text-align: left;">S.I.</td>
<td style="text-align: left;"><span>[</span>m<span>]</span></td>
<td style="text-align: left;"><span>[</span>rad<span>]</span></td>
<td style="text-align: left;"><span>[</span>rad<span>]</span></td>
<td style="text-align: left;">m/s</td>
<td style="text-align: left;"><span>[</span>rad/s<span>]</span></td>
<td style="text-align: left;"><span>[</span>rad/s<span>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>This raises practical concerns—for example, what would be the unit of
acceleration? km/s<span class="math inline">\(^2\)</span>?
parsec/year/second? To systematically manage units, we turn to
dimensional analysis, notably the Buckingham Pi theorem <span
class="citation" data-cites="1914PhRv....4..345B">(Buckingham
1914)</span>. In classical mechanics, physical quantities are typically
expressed in terms of three fundamental dimensions: length, time, and
mass. Any quantity can then be represented as a product of powers of
these base units:</p>
<p><span class="math display">\[\left[\mathrm{Quantity}\right] = l^a t^b
m^c =
            \begin{bmatrix}
                a\\
                b\\
                c
            \end{bmatrix}\]</span></p>
<p>For example, velocity has dimensions <span class="math inline">\([1,
-1, 0]\)</span>, momentum is <span class="math inline">\([1, -1,
1]\)</span>, and acceleration is <span class="math inline">\([1, -2,
0]\)</span>.</p>
<p>It is not strictly necessary to adopt length-time-mass as the
fundamental basis, as long as the three chosen base units are linearly
independent. In stellar dynamics, it is often more natural to use
distance, velocity, and mass as the base units. In this thesis, we
adopt:</p>
<ul>
<li><p>Distance: 1 kpc</p></li>
<li><p>Velocity: 1 km/s</p></li>
<li><p>Mass: 1 solar mass <span
class="math inline">\(\mathrm{M}_\odot\)</span></p></li>
</ul>
<p>In this system, time has derived units of: <span
class="math display">\[\left[t\right] =
\frac{\mathrm{distance}}{\mathrm{velocity}} =
\frac{\mathrm{kpc}}{\mathrm{km/s}}.\]</span> While not immediately
intuitive, this unit of time is convenient because: <span
class="math display">\[1\mathrm{Gyr} \approx
1~\mathrm{s}\cdot\frac{\mathrm{kpc}}{\mathrm{km}}.\]</span></p>
<p>The gravitational constant has dimensions: <span
class="math display">\[\left[G\right]=\frac{v^2 \cdot l}{m},\]</span>
which evaluates numerically to: <span class="math display">\[G = 4.301
\times 10^{-6} \left(\mathrm{km}/\mathrm{s}\right)^2 \cdot \mathrm{kpc}
\cdot \mathrm{M}_\odot^{-1}.\]</span></p>
<p>Once the base units are defined, derived quantities such as
acceleration follow directly. Whether considering acceleration as <span
class="math inline">\(v^2~l^{-1}\)</span> or <span
class="math inline">\(l \cdot t^{-2}\)</span>, they are equivalent and
yield: <span
class="math inline">\(\left(\mathrm{kpc}/\mathrm{s}\right)^2 \cdot
\mathrm{kpc}^{-1}\)</span>.</p>
<p>It is worth mentioning that <span
class="math inline">\(N\)</span>-body codes often select distance,
velocity, and the gravitational constant as the base units, setting
<span class="math inline">\(G = 1\)</span>. While this choice simplifies
force computations, it introduces less intuitive units for mass. For
instance, by choosing 1 kpc for distance and 1 km/s for velocity, and
setting <span class="math inline">\(G = 1\)</span>, the derived mass
unit becomes: <span class="math display">\[\left[\mathrm{mass}\right] =
\frac{l \cdot v^2}{G} = 232509~\mathrm{M}_\odot.\]</span> This approach
was used in our first paper (see Chapter 4).</p>
<p>The famous galactic dynamical python code, <code>Galpy</code> makes a
different choice and introduced <em>natural units</em> <span
class="citation" data-cites="2015ApJS..216...29B">(Bovy 2015)</span>.
More specifically, <span class="citation"
data-cites="2015ApJS..216...29B">Bovy (2015)</span> uses a normalization
in which <span class="math inline">\(R\)</span>, the cylindrical scale
length of the galaxy, and <span
class="math inline">\(v_\mathrm{circ}\)</span>, the circular velocity at
this radius, are both set to 1. This choice is motivated by a galaxy’s
rotation curve and is embodied in: <span
class="math display">\[\frac{v_\mathrm{circ}^2}{R_0} = \nabla  \Phi
\left(R_0, z=0\right).
        \label{eq:vcirc}\]</span> Note that the gravitational constant
is also set to 1. Whatever the form of the potential, the scale lengths
must be normalized to <span class="math inline">\(R\)</span>, and the
mass parameter is subsequently determined through Eq. <a
href="#eq:vcirc" data-reference-type="ref"
data-reference="eq:vcirc">[eq:vcirc]</a>. The total potential is a
linear combination of individual components, with the user selecting the
contribution of each component to the force at the characteristic
radius. For example, <span class="math inline">\(\Phi = \sum_i
a_i\Phi_i\)</span>, where <span class="math inline">\(a_i\)</span> are
weights such that <span class="math inline">\(\nabla \Phi_i(R_0, z=0) =
a_i\)</span> in normalized units. In this system of units, emphasis is
placed on the rotation curve and how much each component contributes to
it at the reference radius of the galaxy. Note that <span
class="math inline">\(v_\mathrm{circ}(R_0)\)</span> is not necessarily
the maximum rotational velocity.</p>
<p>In short, each code presents its own preferred units and
normalization. <code>Tstrippy</code>, by contrast, expects the user to
pass masses in solar masses, velocities in kilometers per second, and
distances in kiloparsecs. However, physical constants are not
hard-coded, so the user may pass any numerical values to the code as
long as they are based on a self-consistent unit system. Nonetheless,
the code comes equipped with parameters for the
<code>pouliasis2017pii</code> potential <span class="citation"
data-cites="2017A&amp;A...598A..66P">(Pouliasis, Di Matteo, and Haywood
2017)</span> and for the catalog of globular clusters <span
class="citation" data-cites="2018MNRAS.478.1520B">(Baumgardt and Hilker
2018)</span> in units of kpc, km/s, and <span
class="math inline">\(\mathrm{M}_\odot\)</span>.</p>
<p>A valid general strategy when developing numerical codes is to
implement a module that converts user-defined units to the internal
units. This functionality also exists in <code>Galpy</code> and a
similar system is implemented in <code>Agama</code> <span
class="citation" data-cites="2018arXiv180208255V">(Vasiliev
2018)</span>. I chose not to add such a layer to <code>Tstrippy</code>
since <code>Astropy</code> provides an excellent unit-handling module
that allows users to convert between units easily <span class="citation"
data-cites="2013A&amp;A...558A..33A">(Astropy Collaboration et al.
2013)</span>, and I recommend its use in the documentation.</p>
<h1 id="solving-the-equations-of-motion">Solving the equations of
motion</h1>
<p>Long before the advent of computers, Euler (1707-1783) proposed a
simple method for numerically solving differential equations. In this
method, a solution is approximated by <span
class="math display">\[y_{i+1} = y_i + \Delta t
\frac{dy}{dt}\left(y_i,t_i\right),\]</span> where <span
class="math inline">\(i\)</span> is a time step index. This means that
at each point <span class="math inline">\((t_i, y_i)\)</span>, the
function is extrapolated forward using a linear approximation.</p>
<p>The accuracy of this method can be understood using a Taylor series
expansion of the exact solution <span class="math inline">\(y(t_i +
\Delta t)\)</span> about <span class="math inline">\(t_i\)</span>: <span
class="math display">\[y(t_i + \Delta t) = y(t_i) + \Delta t y&#39;(t_i)
+ \frac{1}{2!}\Delta t^2 y&#39;&#39;(t_i) + \dots\]</span> Euler’s
method captures only the first two terms. The difference between the
exact solution and the Euler estimate is dominated by the second-order
term. Thus, the <em>local truncation error</em> (error per step) is
<span class="math display">\[\mathrm{Err}_{\mathrm{step}} \approx
\frac{1}{2} \Delta t^2 y&#39;&#39;(t_i) = \mathcal{O}(\Delta
t^2).\]</span></p>
<p>The <em>global error</em> (accumulated over many steps) is
approximately the number of steps times the average error per step:
<span class="math display">\[\mathrm{Err} \approx N_{\mathrm{step}}
\cdot \langle \mathrm{Err}_{\mathrm{step}} \rangle \approx
\frac{T}{\Delta t} \cdot \Delta t^2 \langle y&#39;&#39; \rangle =
\mathcal{O}(\Delta t).\]</span> This means that halving the timestep
roughly halves the global error.</p>
<p>It is important to note that using a taylor series to estimate the
error is not mathematically rigorous and not always generalizable. The
actual error behavior depends strongly on the properties of the function
being integrated. For instance:</p>
<ul>
<li><p>If <span class="math inline">\(y\)</span> is linear in <span
class="math inline">\(t\)</span>, then <span
class="math inline">\(y&#39;\)</span> is constant and Euler’s method
gives the exact result.</p></li>
<li><p>If <span class="math inline">\(y(t) = t^a\)</span>, the local
errors accumulate and grow monotonically.</p></li>
<li><p>If <span class="math inline">\(y\)</span> has curvature that
changes sign, local errors can partially cancel out over the course of
the integration.</p></li>
</ul>
<p>For a more systematic treatment of integration methods and their
error properties, Chapter 16 of <em>Numerical Recipes in C</em> provides
an excellent introduction <span class="citation"
data-cites="1992nrca.book.....P">(Press et al. 1992)</span>.</p>
<p>Regardless of the method used, sanity checks are essential to
validate the result. These include:</p>
<ul>
<li><p>Trying different integration schemes.</p></li>
<li><p>Performing convergence tests to ensure the solution stabilizes as
<span class="math inline">\(\Delta t \to 0\)</span>.</p></li>
<li><p>Leveraging any known properties of the solution to verify
correctness.</p></li>
</ul>
<p>For example, we can exploit the properties of Hamiltonain systems to
design integrators. In this thesis, we implemented the Leapfrog
integrator and the Forest-Ruth scheme <span class="citation"
data-cites="bovy_inprep 1990PhyD...43..105F">(Bovy, n.d.; Forest and
Ruth 1990)</span>. These schemes are derived from the structure of
Hamiltonian mechanics and are known as <em>symplectic integrators</em>.
Before continuing, I would like to quote <span class="citation"
data-cites="bovy_inprep">(Bovy, n.d.)</span>:</p>
<blockquote>
<p>Hamiltonian integrators are often called symplectic. This name comes
from the fact that these integrators are Hamiltonian maps, whose
mathematical structure is that of a vector flow on a symplectic
manifold. Many fine dynamicists have made great contributions to the
field without delving deeply into the meaning of the previous sentence
and we do not discuss this further.</p>
</blockquote>
<p>However, my curiosity about linguistics pushed me to delve further:
What does <em>symplectic</em> mean? <span class="citation"
data-cites="weyl1946classical">Weyl (1946)</span> coined the term
because <em>complex</em> was already taken. The prefix latin
<em>com</em>- refers to <em>together</em>, and <em>plexus</em> comes
from greek meaning “woven” or “braided”. Symplectic translates exactly
the same way: <em>sym</em>- is a Greek prefix for “together.” The idea
remains the same: in Hamiltonian dynamics, the evolution of position and
momentum are interdependent. This becomes clearer in matrix form: <span
class="math display">\[\begin{bmatrix}
            \dot{\bf{q}}\\
            \dot{\bf{p}}
        \end{bmatrix}
         =
        \begin{bmatrix}
            0 &amp; I_n \\
            -I_n &amp; 0
        \end{bmatrix}
                \begin{bmatrix}
            \frac{\partial \mathcal{H}}{\partial \bf{q}} \\
            \frac{\partial \mathcal{H}}{\partial \bf{p}}
        \end{bmatrix}
        \label{eq:symplectic}\]</span> Here, the skew-symmetric matrix
“weaves” the positions and momenta together.</p>
<p>Although the equations of motion do not admit analytical solutions,
they possess several known properties. First, trajectories governed
solely by gravity are time-reversible. This property is important for
our methodology, where we integrate the equations of motion backward in
time and then forward again to the present-day position. Secondly, the
total orbital energy is conserved. Moreover, according to Liouville’s
theorem, Hamiltonian flows preserve the local phase space volume. A
corollary of this is that the determinant of the Jacobian matrix of the
transformation from <span
class="math inline">\(\left(q,p\right)\rightarrow
\left(q&#39;,p&#39;\right)\)</span> must be one, which means that the
transformation only rotates or translates an infinitesimal volume but
does not shrink or expand the volume. We can view the transform as:
<span class="math display">\[\begin{aligned}
        q&#39; &amp;= q + \frac{\partial \mathcal{H}}{\partial p}\Delta
t, \\
        p&#39; &amp;= -\frac{\partial \mathcal{H}}{\partial q}\Delta t +
p,
    
\end{aligned}\]</span> The Jacobian matrix is given by <span
class="math inline">\(\left(\frac{\partial x_i&#39;}{\partial x_j
}\right)\)</span>: <span class="math display">\[\begin{bmatrix}
            1 &amp; \Delta t \frac{\partial^2 \mathcal{H}}{\partial p^2}
\\  
            -\Delta t \frac{\partial^2 \mathcal{H}}{\partial q^2} &amp;
1 \\  
        \end{bmatrix}\]</span> and the subsequent determinant is: <span
class="math display">\[\mathrm{det}\left(J\right) = 1 - \Delta t^2
\frac{\partial^2 \mathcal{H}}{\partial q^2} \frac{\partial^2
\mathcal{H}}{\partial p^2}.\]</span> In general, neither <span
class="math inline">\(\frac{\partial^2 \mathcal{H}}{\partial
q^2}\)</span> or <span class="math inline">\(\frac{\partial^2
\mathcal{H}}{\partial p^2}\)</span> are zero. There is a quick fix to
this dilema, namely, only stepping in <span
class="math inline">\(q\)</span> or <span
class="math inline">\(p\)</span> while holding the other constant. In
turn, the transformation of a single step will have a Jacobian whose
determinant is 1. The transformation order becomes: <span
class="math inline">\((q,p) \rightarrow (q&#39;,p) \rightarrow
(q&#39;,p&#39;)\)</span>. This is commonly referred to as a sequence of
<em>drifts</em> and <em>kicks</em>. A <em>drift</em> updates the
position while holding the momentum fixed, and a <em>kick</em> updates
the momentum while holding the position fixed. Symplectic integrators
alternate these operations in a specific sequence to preserve the
Hamiltonian and phase space volume.</p>
<p>The scheme outlined above is essentially a first-order method and is
closely related to Euler’s method. More sophisticated integrators use
values from multiple time steps to construct higher-order estimates of
the system’s evolution. For example, some schemes temporarily evolve the
position to an intermediate value <span
class="math inline">\(q_\mathrm{temp}\)</span>, use this to compute a
momentum <span class="math inline">\(p_\mathrm{temp}\)</span>, and then
adjust both using weighted averages or predictor-corrector steps to
reach the final state. These methods carefully balance forward and
backward steps to optimize accuracy while preserving the symplectic
structure.</p>
<p>One of the most commonly used integrators in galactic dynamics is the
leapfrog method. It works by interleaving updates of positions and
momenta using time-centered averages. Specifically, the average momentum
between <span class="math inline">\(q_i\)</span> and <span
class="math inline">\(q_{i+1}\)</span> (denoted <span
class="math inline">\(p_{i+1/2}\)</span>) is used to advance the
position, and then the average force (derived from the potential) is
used to update the momentum. In Cartesian coordinates—used throughout
this thesis—the leapfrog algorithm can be written as:</p>
<p><span class="math display">\[\begin{aligned}
        x_{i+1/2} &amp;= x_i + \frac{1}{2} \dot{x}_i \Delta t , \\
        \ddot{x}_{i+1/2} &amp;= -\nabla \Phi(x_{i+1/2}), \\
        \dot{x}_{i+1} &amp;= \dot{x}_i + \ddot{x}_{i+1/2} \Delta t, \\
        x_{i+1} &amp;= x_{i+1/2} + \frac{1}{2} \dot{x}_{i+1} \Delta t.
    
\end{aligned}\]</span> As will be shown in the next section, the
leapfrog algorithm is sufficient. However, the question of computational
efficiency and numerical accuracy is ever present. Leapfrog uses the two
local points about the position and momenta to evolve them. Other
schemes can use more points to have more accurate estimations for the
local derivatives.</p>
<p><span class="citation" data-cites="1990PhyD...43..105F">Forest and
Ruth (1990)</span> proposed one such method for symplectic integrations.
The method involves finding roots of high order polynomials, and the
roots of which determine the weights and distances about the local point
for finding the best estimate of the derivative for evoling the system.
The method involves solving a cubic polynomial to determine the optimal
coefficients. While the derivation is mathematically involved, the final
scheme is straightforward to implement. I implemented this method and
tested its efficiency against the leapfrog and present the results in
the following section. There are eight coefficients in this method,
which are presented in table <a href="#tab:forest_ruth_coeffs"
data-reference-type="ref"
data-reference="tab:forest_ruth_coeffs">2</a>.</p>
<div id="tab:forest_ruth_coeffs">
<table>
<caption>Velocity (<span class="math inline">\(c_n\)</span>) and
acceleration (<span class="math inline">\(d_n\)</span>) coefficients for
the Forest-Ruth symplectic integrator.</caption>
<tbody>
<tr>
<td colspan="4" style="text-align: center;">Velocity coefficients (<span
class="math inline">\(c_n\)</span>)</td>
<td colspan="4" style="text-align: center;">Acceleration coefficients
(<span class="math inline">\(d_n\)</span>)</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(c_1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(c_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(c_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(c_4\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_4\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(w +
\frac{1}{2}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-w\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-w\)</span></td>
<td style="text-align: center;"><span class="math inline">\(w +
\frac{1}{2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2w +
1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-4w -
1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2w +
1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>The coefficients are all based on the solution to the cubic
polynomial: <span class="math inline">\(48 w^3 + 24 w^2 - 1 =
0\)</span>. For a single step, the positions and velocities are updated
as follows: <span class="math display">\[\begin{aligned}
        x&#39; &amp;= x + c_n v \Delta t \\
        t&#39; &amp;= t + c_n \Delta t \\
        \ddot{x} &amp;= \nabla \Phi (x&#39;) \\
        \dot{x}&#39; &amp;= \dot{x} + d_n \ddot{x} \Delta t,
    
\end{aligned}\]</span> where <span class="math inline">\(n\)</span> is
the <em>mini-step</em>. Notice that the sum of <span
class="math inline">\(\sum_n^4 c_n\)</span> and <span
class="math inline">\(\sum_n^4 d_n\)</span> both equal 1, which is a
full time step <span class="math inline">\(\Delta t\)</span>.</p>
<p>Lastly, it is important to note that the leapfrog algorithm is
symplectic and time-reversible only for Hamiltonians that are both
time-independent and separable—that is, where the Hamiltonian can be
written as a sum of a kinetic term depending only on momenta, <span
class="math inline">\(T(p)\)</span> and whose potential depends only on
position <span class="math inline">\(\Phi(q)\)</span>. These conditions
are satisfied for systems in an inertial frame with conservative forces.
This is true when integrating the motion for the center of mass of the
globular clusters. However, the Hamiltonian for the integration of the
particles does depend on time. So the leapfrog algorithm may introduce
systematic integration errors due to the violation of its underlying
assumptions, beyond ordinary rounding errors.</p>
<p>Similarly, when we integrate the orbits of either the particles or
the globular clusters in the Galaxy containing a galactic bar, we are
faced with a choice: we can either work in a time-dependent inertial
frame, where the potential rotates and the Hamiltonian explicitly
depends on time, or we can transform to a rotating frame, in which case
the kinetic energy becomes position-dependent due to Coriolis and
centrifugal forces, which breaks the necessary criteron of separability:
<span class="math inline">\(\mathcal{H}(q,p) = T(p)+\Phi(q)\)</span>. In
both cases, the standard assumptions of the leapfrog algorithm are
violated.</p>
<p>Nonetheless, we will continue to use leapfrog as it remains a robust
and efficient integrator for a wide range of astrophysical systems. Its
good long-term energy behavior makes it a reasonable approximation even
when the ideal assumptions are not strictly met. However, this
highlights the need for careful validation: we must verify that the
integration errors remain within acceptable bounds, especially in
systems with non-separable or time-dependent dynamics. This validation
is the subject of the next section.</p>
<h1 id="numerical-error-computation-time">Numerical Error &amp;
Computation Time</h1>
<p>To ensure the quality of the integration, we perform two main checks.
The first is to ensure that the initial orbital energy of a given
particle is conserved to high precision. At each timestep, the relative
error in the energy conservation is: <span
class="math inline">\(\mathrm{err}(E) = \left|\frac{E -
E_0}{E_0}\right|\)</span>, where <span
class="math inline">\(E_0\)</span> is the initial energy and <span
class="math inline">\(E\)</span> is the orbital energy at the index for
a given time step <span class="math inline">\(t_i\)</span>. For the case
of just globular clusters, the orbital energy is its own kinetic energy
plus its gravitational potential energy in the Galaxy: <span
class="math inline">\(E = T(\textbf{v}) +
\Phi_{\mathrm{MW}}\left(\textbf{x}\right)\)</span>. For the case of a
star-particle within a globular cluster, the potential energy of the
cluster is included: <span class="math inline">\(E_i = T(\textbf{v}_i) +
\Phi_{\mathrm{MW}}\left(\textbf{x}_i\right) +
\Phi_\mathrm{GC}\left(\textbf{x}_i -
\textbf{x}_{\mathrm{GC},i}\right)\)</span>. The same approach holds when
a galactic bar is included, the only difference being that the Galactic
potential has a time-dependent element.</p>
<p>The second check is that simulations are time-reversable. In this
case, we integrate a cluster back in time, and then change the sign of
its velocity to subsequently integrate forward in time. If the
integration is correct, the cluster should remain on the same trajectory
retracing its steps. We investigate this for four scenarios and show the
results below:</p>
<ul>
<li><p>The globular cluster population orbiting with a time-static Milky
Way potential;</p></li>
<li><p>Star-particles orbiting with a stationary and isolated globular
cluster;</p></li>
<li><p>Full stream generation, i.e., star particles orbiting within a
globular cluster that orbits the Galaxy,</p></li>
<li><p>The globular clusters orbiting in a potential with a galactic
bar;</p></li>
<li><p>Star-particles orbiting within a globular cluster in a Milky Way
with a Galactic bar.</p></li>
</ul>
<h2 id="globular-cluster-orbits-in-a-static-galaxy">Globular Cluster
Orbits in a Static Galaxy</h2>
<p>As explained in the next chapter, the initial conditions for the
globular cluster system (positions and velocities) were taken from <span
class="citation" data-cites="2018MNRAS.478.1520B">Baumgardt and Hilker
(2018)</span>’s online globular cluster catalog whose data derived from
Gaia Early Data Release 3 among other sources <span class="citation"
data-cites="2021MNRAS.505.5957B 2021A&amp;A...649A...1G 2023A&amp;A...674A...1G">(Baumgardt
and Vasiliev 2021; Gaia Collaboration et al. 2021, 2023)</span>.</p>
<p>To test the integrator, we integrated the whole globular cluster
system for 5 Gyr, and then integrated it back to the initial conditions.
We used four time steps: <span
class="math inline">\(10^4,10^5,10^6,10^7\)</span> years which
corresponds to <span
class="math inline">\(\left[500,5000,50000,500000\right]\)</span>
integration steps, respectively. In general, the time step should scale
with the dynamical time of the orbit, or be inversely proportional to
the orbital energy. The farther the system is from the center, the
larger the time step that can be used to obtain a given numerical error.
Of course, the timestep does not just simply scale with a body’s orbital
energy, it should scale with the maximum acceleration experienced in the
system. A highly eccentric orbit requires a smaller timestep to properly
integrate the motion near the pericenter, compared to a circular orbit
at the same orbital energy. To not clutter the graph, Fig. <a
href="#fig:numericalErrorLeapFrogVanilla" data-reference-type="ref"
data-reference="fig:numericalErrorLeapFrogVanilla">1</a> only present
the whole globular cluster system twice, once integrated with the
smallest timestep, <span class="math inline">\(10^4\)</span> years, and
once with the largest timestep: <span
class="math inline">\(10^7\)</span> years.</p>
<figure id="fig:numericalErrorLeapFrogVanilla">
<img src="images/numericalErrorLeapFrogVanilla.png" />
<figcaption>Error in orbital energy for the whole globular cluster
system with two different time steps, dt = <span
class="math inline">\(10^{7}\)</span> and <span
class="math inline">\(10^{4}\)</span> years. Each cluster’s is colored
by its initial orbital energy. The average of the whole system for a
given timestep is indicated with dotted and solid black lines,
respectively.</figcaption>
</figure>
<p>In Fig. <a href="#fig:numericalErrorLeapFrogVanilla"
data-reference-type="ref"
data-reference="fig:numericalErrorLeapFrogVanilla">1</a> we can notice
that orbits with higher orbital energies (in red) have low numerical
error compared to those with lower energies (in blue), which penetrate
deeper in the potential well. It is clear that, for the whole system,
<span class="math inline">\(10^7\)</span> years is a time step that is
far too large, however, interestingly enough, for some of the farthest
globular clusters, a time step of 10 million years resolves their orbits
to an error of <span class="math inline">\(\langle \Delta E / E_0
\rangle \sim 10^{-5}\)</span>, which is still far less than the
uncertainties in the energy due to both modeling and observational
uncertainties.</p>
<p>Fig. <a href="#fig:numericalErrorReverseIntegration"
data-reference-type="ref"
data-reference="fig:numericalErrorReverseIntegration">2</a> presents the
<em>time reversibility</em>, or the integrator’s ability to retrace its
own steps. For each given time step, I report the difference between the
initial integration and the retrace normalized to the mean of the two
position’s. I perform the same computation for the velocities. The time
step of <span class="math inline">\(10^7\)</span> yr saturates only
after 2 Gyr. The distances do not continue to grow becuase the orbital
energy only differs by one part in ten, so at later time steps, the
cluster is still within the same region of phase-space, but the retrace
is at a completely different location than the initial integration. The
errors in the time step of <span
class="math inline">\(10^6\)</span> yrbecome significant, though by the
end of the integration period of 5 Gyr they are still only one part in
ten thousand. The time steps of <span
class="math inline">\(10^5\)</span> and <span
class="math inline">\(10^4\)</span> yr have excellent retraceability and
on average, only differ by one part in <span
class="math inline">\(10^{-14}\)</span>, and are thus only limited by
round off error from the use of double precision floating point
numbers.</p>
<figure id="fig:numericalErrorReverseIntegration">
<img src="images/numericalErrorReverseIntegration.png" />
<figcaption>The <em>time-reversability</em> of the Leapfrog scheme for
the 165 Galactic globular cluster’s for four different time steps
indicated in the legend. The whole system is only shown for <span
class="math inline">\(10^4\)</span> yr and <span
class="math inline">\(10^7\)</span> yr to avoid clutter. The clusters
are color-coded to their initial orbital energy just as Fig. <a
href="#fig:numericalErrorLeapFrogVanilla" data-reference-type="ref"
data-reference="fig:numericalErrorLeapFrogVanilla">1</a></figcaption>
</figure>
<p>Computation time is quite important. Fig. <a
href="#fig:numericalErrorGlobularClustersComputationTime"
data-reference-type="ref"
data-reference="fig:numericalErrorGlobularClustersComputationTime">3</a>
presents the total computation time of integrating the globular cluster
system, and the time of a single integration step, which is computed by
normalizing the total time by the number of objects and number of steps
taken: <span
class="math inline">\(T_{\mathrm{total}}/N_{\mathrm{GCs}}/N_{\mathrm{steps}}\)</span>.
In general, the relationship is linear and the integration time per step
per object is roughly constant. The downward trend presented in Fig. <a
href="#fig:numericalErrorGlobularClustersComputationTime"
data-reference-type="ref"
data-reference="fig:numericalErrorGlobularClustersComputationTime">3</a>
is in part a coincidence, as some time realizations minimize this, and
in part due to the overhead computation time with initializing and
finalizing the calculation contributes less and less with increasing
integration time. Nonetheless, for this processor, for a single
integration step the mean time is <span
class="math inline">\(\sim\)</span> 128 nanoseconds.</p>
<figure id="fig:numericalErrorGlobularClustersComputationTime">
<img src="images/numericalErrorGlobularClustersComputationTime.png" />
<figcaption>Computation time for integrating the entire globular cluster
system using the leapfrog scheme. The top panel shows the total time
while the bottom shows computation time for a single step, for a single
object being integrated. This was performed on a 2022 MacBook Air with
an Apple M2 processor. </figcaption>
</figure>
<p>The Ruth-Forest algorithm discussed in the previous section was
implemented and is reported in Fig. <a
href="#fig:numericalErrorRuthForest" data-reference-type="ref"
data-reference="fig:numericalErrorRuthForest">4</a>. Here, as expected,
we see that the percision greatly increases when decreasing the time
step. However, since there are four force evaluations for the for a
single timestep, this method is naturally slower perstep than leapfrog.
How do the two methods compare over all?</p>
<figure id="fig:numericalErrorRuthForest">
<img src="images/numericalErrorRuthForest.png" />
<figcaption>The conservation of energy error for the Ruth-Forest
integration scheme for the globular cluster system. This plot is similar
to Fig. <a href="#fig:numericalErrorLeapFrogVanilla"
data-reference-type="ref"
data-reference="fig:numericalErrorLeapFrogVanilla">1</a>, but does not
preesnt on the whole globular cluster system, just the average error in
energy for the whole system with a given time step. The time step and
time-average numerical error for the whole system is presented next to
each curve. The average computation time per integration step per single
object is as well.</figcaption>
</figure>
<p>Fig. <a href="#fig:numericalErrorMeanEnergyErrorRuthForestLeapFrog"
data-reference-type="ref"
data-reference="fig:numericalErrorMeanEnergyErrorRuthForestLeapFrog">5</a>
compares the numerical error for again the total number of steps (which
is inversely propertial to the time step). It is clear that for a given
step size, the Ruth-forest out performs the leap frog, but is it
actually better? To answer this question, I fit the two curves with
their own trend lines to find the number of steps required to have a
relative error of <span class="math inline">\(10^{-8}\)</span>. With
this requirement, The leapfrog sceme requires 262,641 steps while the
Ruth-Forest scheme requires 102,773 steps. However, given the difference
in computation time per step, on average, the Forest-Ruth scheme takes
<span class="math inline">\(\sim 1.5\)</span>x more time for the same
degree of numerical precision than the leapfrog. For this reason, we use
the leapfrog algorithm. In this problem, numerical uncertainties are
must less of a limiting factor compared to modeling uncertainties and
observational uncertainties, so a better integrator for numerical
precision is not worth the pay off of longer computation times.</p>
<figure id="fig:numericalErrorMeanEnergyErrorRuthForestLeapFrog">
<img src="images/numericalErrorMeanEnergyErrorRuthForestLeapFrog.png" />
<figcaption>The time averaged error in the conservation of energy for
the entire globular cluster system for four different time steps, for
two different integration techinques: the Leapfrog against the
Ruth-Forest. Their respective trend lines are shown.</figcaption>
</figure>
<h2 id="star-particles-in-a-static-globular-cluster">Star-particles in a
static globular cluster</h2>
  <div class="video-container">
    <video controls style="max-width: 100%;">
      <source src="videos/cluster_showing_scale_and_dynamical_time.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>
  </div>
<p>A classic problem in astronomy and the physical sciences is that
there are two different physical phenomena that are relevent to your
problem but they have two very different time scales. This is certainly
the case with globular clusters. Fig. <a
href="#fig:GCsystemCharacteristicTimes" data-reference-type="ref"
data-reference="fig:GCsystemCharacteristicTimes">6</a> shows the order
of magnitude differences in time scales across the globular cluster
population as well as within an individual cluster.</p>
<figure id="fig:GCsystemCharacteristicTimes">
<img src="images/GCsystemCharacteristicTimes.png" />
<figcaption>The top panel shows orbital characteristic times of the
globular cluster system, while the bottom panel shows internal
characteristic times for three selected clusters. <em>Top</em>: The red
distribution shows the orbital crossing time of each cluster within the
Galaxy, while the blue distribution shows a characteristic internal
dynamical time. <em>Bottom</em>: The distribution of crossing times for
1,000 sampled star particles within the globular clusters with the
smallest, median, and largest internal dynamical times. These times are
inversely proportional to the clusters’ densities and are computed with
isotropic Plummer distributions.</figcaption>
</figure>
<figure>
<img src="images/GCsystemStabilityDynamicalTimeRatios.png" />
<figcaption>Ratio of each globular clusters’ galactic crossing time to
it’s own internal dynamical time, which, individually, are the top
distributions from Fig. <a href="#fig:GCsystemCharacteristicTimes"
data-reference-type="ref"
data-reference="fig:GCsystemCharacteristicTimes">6</a>. Clusters’ whose
dynamical time approaches the crossing time are almost disrupted. Those
that are must more dense are far more stable and not close to being
disrupted. The vertiable bars show the selected thresholds for each.
Both lists present stability in asending order, where Gran 1 is the
least stable and NGC 6229 is the most stable. </figcaption>
</figure>
<p>Given the variety of timescales involved in this problem, how do we
choose an appropriate timestep? The first is to recognize the practical
constrain, which is that the number of steps needs to be an integer and
divide the total integration time evenly by the timesteps: <span
class="math display">\[\Delta t = \frac{T}{N} =
\frac{T}{2^{k-1}}\]</span> where <span class="math inline">\(N\)</span>
is the number of steps and <span class="math inline">\(k\)</span> is the
number of intervals. <span class="math inline">\(N\)</span> must be an
integer, so our criterion is that ensures the timestep is some fraction
of a desired time and one that ensures <span
class="math inline">\(N\)</span> properly divides the entire period into
<span class="math inline">\(N\)</span>-1 equal segments. Our criterion
is that the timestep will be some factor <span
class="math inline">\(\alpha\)</span> of the dynamical time <span
class="math inline">\(\tau_\mathrm{dyn}\)</span>. This criterion is
thus: <span class="math display">\[\log_2\left(\frac{T}{\alpha
\tau_\mathrm{dyn}}\right) + 1 &lt; k.\]</span> The smallest number of
intervals to make is thus rounding the criterion up to the nearest whole
number: <span class="math inline">\(\left\lceil
\log_2\left(\frac{T}{\alpha \tau_\mathrm{dyn}}\right) +
1  \right\rceil\)</span>.</p>
<p>Now, what is a good <span class="math inline">\(\alpha\)</span> to
ensure good energy conservation and time-reversability? From Fig. <a
href="#fig:GCsystemCharacteristicTimes" data-reference-type="ref"
data-reference="fig:GCsystemCharacteristicTimes">6</a>, we see that the
typical globular cluster has a crossing time of <span
class="math inline">\(5\times10^{7}~\mathrm{yr}\)</span>. From Fig. <a
href="#fig:numericalErrorLeapFrogVanilla" data-reference-type="ref"
data-reference="fig:numericalErrorLeapFrogVanilla">1</a> that selecting
a <span class="math inline">\(\Delta t\)</span> of <span
class="math inline">\(10^{4}~\mathrm{yr}\)</span>, which is <span
class="math inline">\(2\times 10^{-4}\)</span> that of the crossing
time, we have conserve energy with a relative error of <span
class="math inline">\(10^{-8}\)</span>. Then, from Fig. <a
href="#fig:numericalErrorReverseIntegration" data-reference-type="ref"
data-reference="fig:numericalErrorReverseIntegration">2</a>, we see that
<span class="math inline">\(\Delta t= 10^{5}~\mathrm{yr}\)</span>
already converges to the best we can do for time-reversability, which is
<span class="math inline">\(2\times10^{-3}\)</span> the
crossing-time.</p>
<figure id="fig:numericalErrorStaticPlummerSphereEnergyError">
<img src="images/numericalErrorStaticPlummerSphereEnergyError.png" />
<figcaption>The relative error of the energy conservation for a plummer
sphere with different time steps. Each sphere was sampled with a the
same number of particles, <span class="math inline">\(N\)</span>, and
integrated for the same amount of time, <span
class="math inline">\(T\)</span>, both of which are indicated on the
plot. The x-axis is the size of the time-step, <span
class="math inline">\(\alpha\)</span>, which is the fraction of the
internal dynamical time, <span class="math inline">\(\tau =
\sqrt{\frac{a^3}{GM}}\)</span>. </figcaption>
</figure>
<h2 id="full-stream-generation">Full stream generation</h2>
<p>The preceding sections assessed the numerical stability of
integrating globular cluster orbits within the Milky Way, focusing on
time-reversibility and relative energy error across two integration
schemes: leapfrog and Forest-Ruth. I also considered the computational
cost associated with different temporal resolutions. Separately, I
evaluated the energy conservation for star particles evolving within a
stationary Plummer sphere, quantifying the relative error as a function
of timestep. In that context, the cluster’s potential was scaled to its
scale radius, mass, and the gravitational constant. This
non-dimensionalization allowed me to select timesteps as fractions of
the internal dynamical time <span class="math inline">\(\tau\)</span> of
each cluster.</p>
<p>In this section, I combine these two components: I examine the
quality of orbit integration for star particles evolving within a
globular cluster, itself orbiting in the Galactic potential.</p>
<p>I restrict the analysis here to the leapfrog integrator for two main
reasons. First, although the Forest-Ruth scheme achieves better energy
conservation (see Fig. <a
href="#fig:numericalErrorMeanEnergyErrorRuthForestLeapFrog"
data-reference-type="ref"
data-reference="fig:numericalErrorMeanEnergyErrorRuthForestLeapFrog">5</a>),
this comes at a significantly higher computational cost, which outweighs
its marginal gains for this application. Second, the equations of motion
used to model stream generation (see Eq. XXX in the theory chapter)
require loading the center-of-mass orbit of the host cluster at each
simulation time. Because Forest-Ruth evaluates forces at non-uniform
substeps, using it would require either: (1) storing and loading the
cluster orbit at each substep, which would demand excessive disk space
and complex code restructuring; or (2) interpolating the orbit at
intermediate times, which introduces ambiguity regarding whether
time-reversibility is preserved with linear or cubic interpolation. For
these reasons, I opted not to explore Fores-Ruth further in the context
of full stream generation.</p>
<p>To assess the performance of the stream-generation method, I designed
a quality assurance experiment illustrated in Fig. <a
href="#fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155">8</a>.
I began by integrating the orbit of a globular cluster’s center of mass
backward in time by 1 Gyr. At this point, a Plummer sphere was sampled
using the cluster’s half-mass radius and mass, with 512 star particles.
This system was translated to the center-of-mass phase-space coordinates
and then integrated forward in time to the present day, forming a
stream. I saved the resulting positions and computation time. To assess
time-reversibility, I then integrated the stream particles backward
again for 1 Gyr.</p>
<p>A note on terminology: although the cluster orbit is initialized from
present-day observations, in the context of stream generation, I refer
to the past position (1 Gyr ago) as the “initial conditions”. The
forward-integrated system represents the “stream”, and the
backward-integrated version of the stream is referred to as the
“retrace”.</p>
<p>Figures <a
href="#fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155">8</a>
and <a
href="#fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_4096_stepsPerTau_1"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_4096_stepsPerTau_1">9</a>
show the results of this experiment across four different timesteps. As
expected, increasing the timestep degrades time-reversibility and
worsens energy conservation.</p>
<figure
id="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155">
<p><img
src="images/NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155.png"
alt="image" /> <img
src="images/NumericalErrorStreamRetrace_NGC6171_Nsteps_131072_stepsPerTau_38.png"
alt="image" /></p>
<figcaption>Time-reversibility test for NGC 6171. The cluster’s orbit
was integrated backward by 1 Gyr, and a Plummer sphere of 512 particles
was initialized at that position ("Initial"). The system was then
integrated forward ("Stream") and backward again ("Retrace"). Right
panels show the relative error in energy. The timestep was selected as a
fraction of the internal dynamical time <span
class="math inline">\(\tau\)</span>.</figcaption>
</figure>
<figure
id="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_4096_stepsPerTau_1">
<p><img
src="images/NumericalErrorStreamRetrace_NGC6171_Nsteps_16384_stepsPerTau_4.png"
alt="image" /> <img
src="images/NumericalErrorStreamRetrace_NGC6171_Nsteps_4096_stepsPerTau_1.png"
alt="image" /></p>
<figcaption>Same experiment as in Fig. <a
href="#fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155">8</a>,
but using larger timesteps as indicated. Time-reversibility and energy
conservation degrade as timestep increases.</figcaption>
</figure>
<p>The two smaller timesteps in Fig. <a
href="#fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155">8</a>
sufficiently retrace the cluster’s initial configuration. I compare each
particle’s energy change between its initial and retraced state. For
<span class="math inline">\(\Delta t \sim 6\times10^{-3}~\tau\)</span>,
the relative energy errors in the retraced state fall mostly between
<span class="math inline">\(10^{-7}\)</span> and <span
class="math inline">\(10^{-4}\)</span>. For <span
class="math inline">\(\Delta t \sim 3\times10^{-2}~\tau\)</span>, the
distribution shifts upward by about an order of magnitude, indicating
reduced accuracy.</p>
<p>Interestingly, the energy distributions at the present-day timestep
(i.e., for the stream) fall between <span
class="math inline">\(10^{-4}\)</span> and <span
class="math inline">\(10^{-1}\)</span> across all cases, and are largely
insensitive to timestep. This is expected: the equations of motion are
time-dependent due to the non-autonomous external Galactic potential, so
energy is not conserved by design. The fact that energy errors do not
vary strongly with timestep suggests that even the coarsest resolutions
used here are adequate for capturing the global motion within the
Galactic potential. As shown in Figs. <a
href="#fig:numericalErrorLeapFrogVanilla" data-reference-type="ref"
data-reference="fig:numericalErrorLeapFrogVanilla">1</a> and <a
href="#fig:numericalErrorRuthForest" data-reference-type="ref"
data-reference="fig:numericalErrorRuthForest">4</a>, timesteps of <span
class="math inline">\(\sim10^5\)</span> years are sufficient for stable
orbit integration. Even the largest timestep used in the bottom panel of
Fig. <a
href="#fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_4096_stepsPerTau_1"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_4096_stepsPerTau_1">9</a>
corresponds to <span class="math inline">\(\sim10^5\)</span>
years—comparable to the cluster’s internal dynamical time.</p>
<p>Although energy is not conserved in these simulations—since the
Hamiltonian includes a time-dependent Galactic potential—we find that
the energy change for stream particles remains bounded around a relative
error of <span class="math inline">\(10^{-1}\)</span>. Why is this the
case?</p>
<p>Consider a thought experiment: suppose the globular cluster were
removed, and the stars were left to orbit freely in the Galactic
potential. The initial velocities and positions of the stars would still
reflect the distribution sampled from the Plummer sphere. As a result,
they would exhibit a range of orbital energies rather than a single
value. This intrinsic energy spread, denoted <span
class="math inline">\(\sigma_E\)</span>, is not a numerical artifact but
a physical property of the system’s initial conditions.</p>
<p>The relative spread in energies, <span class="math inline">\(\sigma_E
/ E_0\)</span>, where <span class="math inline">\(E_0\)</span> is the
mean orbital energy of the system, provides an estimate of the apparent
"energy error" we observe. We can make a rough estimate of this ratio by
comparing the internal potential energy scale of the cluster to its
orbital energy in the Galaxy. The characteristic internal potential is
on the order of <span class="math inline">\(\Phi \sim GM/a\)</span>,
where <span class="math inline">\(M \sim 10^5~M_\odot\)</span> and <span
class="math inline">\(a \sim 0.005\)</span> kpc, yielding <span
class="math inline">\(\Phi \sim
10^2~\mathrm{km}^2\,\mathrm{s}^{-2}\)</span>. In contrast, the typical
orbital energy of a globular cluster in the Milky Way is about <span
class="math inline">\(10^5~\mathrm{km}^2\,\mathrm{s}^{-2}\)</span> (see
Fig. <a href="#fig:energy_sensitivity_analysis_MWGCS_to_distance_RV_mu"
data-reference-type="ref"
data-reference="fig:energy_sensitivity_analysis_MWGCS_to_distance_RV_mu">[fig:energy_sensitivity_analysis_MWGCS_to_distance_RV_mu]</a>).</p>
<p>This discrepancy of roughly three orders of magnitude implies that
the intrinsic energy spread from the initial Plummer sampling is about
<span class="math inline">\(10^{-3}\)</span> times the absolute orbital
energy. However, since we are examining the energy relative to each
particle’s initial value—which is small—the observed fractional
differences cluster around <span class="math inline">\(\sim
10^{-1}\)</span>, consistent with what we measure in the stream. Thus,
the apparent energy “error” reflects not integration drift but the
physical energy distribution inherited from the initial conditions.</p>
<p>Fig. <a
href="#fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155">8</a>
&amp; Fig. <a
href="#fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_4096_stepsPerTau_1"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_4096_stepsPerTau_1">9</a>
demonstrate the case of a single cluster. How is the energy conservation
for the entire catalog? Fig. <a
href="#fig:NumericalErrorStreamRetraceEnergyConservation"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetraceEnergyConservation">10</a>
presents the realtive error in the conservation of energy for retracing
the orbit of each individual star particle per globular cluster for each
cluster in the catalog. Each data point reports the mean error in the
conservation of energy. Each cluster was integrated for 5 Gyr. The upper
limits for the timesteps were sampeld logarithmically between <span
class="math inline">\(10^{0}\)</span> and <span
class="math inline">\(10^{-2}\)</span>.</p>
<p>From inspecting Fig. <a
href="#fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_524288_stepsPerTau_155">8</a>,
a time step less than <span
class="math inline">\(3\times10^{-2}~\tau\)</span> is great for
retracing the orbit of each star particle and even <span
class="math inline">\(2\times10^{-1}~\tau\)</span> isn’t horrible. This
would place the retrace energy conservation between <span
class="math inline">\(10^{-5}-10^{-3}\)</span> on average per
system.</p>
<figure id="fig:NumericalErrorStreamRetraceEnergyConservation">
<img src="images/NumericalErrorStreamRetraceEnergyConservation.png" />
<figcaption>The conservation of energy for the retrace of each globular
cluster in the catalog. Each cluster was sampled with 512 particles and
integrated for 5 Gyr. Four upper thresholds for each time step were
logarithmically sampled between <span
class="math inline">\(10^{0}\)</span> and <span
class="math inline">\(10^{-2}\)</span>, and selected individually for
each cluster in combination with it’s internal dynamical time that
evenly divided the integration time. </figcaption>
</figure>
<p>The quality of the solutions is fundamental for proper results.
However, computation time and cost is also very important. The spirit of
choosing to solve the restricted three body problem instead of modeling
the system as an N body for a faster computation. With N body, the
computation time should scale with <span
class="math inline">\(N_p^2\)</span>, while for the restricted three
body problem it should scale with <span
class="math inline">\(N_p\)</span>. For both, it should scale linearly
with the number of integration steps.</p>
<p>How does <code>tstrippy</code> perform? Fig. <a
href="#fig:NumericalErrorComputationTimeScalingForStreams"
data-reference-type="ref"
data-reference="fig:NumericalErrorComputationTimeScalingForStreams">11</a>
presents an the results from an experiment with all the globular
clusters integrating them each for 1 Gyr. I choose the timestep to be at
most 1/20 of each internal dynamical time, thus since each cluster has a
different dynamical time, it will require a different number of steps.
For each of these tests I use <span
class="math inline">\(10^1,~10^2,~10^2,~10^3\)</span> particles and
launched them on cluster at the paris observatory. Then, I fit a scaling
law of <span class="math inline">\(C(N_p,N_s) = \langle C\rangle N_p^a
N_s^b\)</span>. If the code scales linearly, then each exponent, <span
class="math inline">\(a,~b\)</span>, should be 1 and <span
class="math inline">\(\langle C\rangle\)</span> would be the mean
computation time.</p>
<p>Fig <a href="#fig:NumericalErrorComputationTimeScalingForStreams"
data-reference-type="ref"
data-reference="fig:NumericalErrorComputationTimeScalingForStreams">11</a>
shows that the code is <em>less</em> efficient than linear scaling with
number of particles, since the best fit exponent is <span
class="math inline">\(1.35\)</span>. However, it scales <em>better</em>
than linear with the number of steps. Perhaps this can be explained by
the fact that there is overhead time involved for initiating and ending
each simulation. As the number of steps increases the fixed overhead
proportionally takes up less of the total time. Since the power law has
an exponent of <span class="math inline">\(0.95\)</span>, the overhead
is marginal. However, it is fortunate that the exponent is not greater
than 1, which would mean the code would slow down with execution
time.</p>
<figure id="fig:NumericalErrorComputationTimeScalingForStreams">
<img src="images/NumericalErrorComputationTimeScalingForStreams.png" />
<figcaption>How the computation scale time scales with the number of
particles and the number of steps taken.</figcaption>
</figure>
<p>Putting Fig. <a
href="#fig:NumericalErrorStreamRetraceEnergyConservation"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetraceEnergyConservation">10</a>
and Fig. <a href="#fig:NumericalErrorComputationTimeScalingForStreams"
data-reference-type="ref"
data-reference="fig:NumericalErrorComputationTimeScalingForStreams">11</a>
together, we get can estimate for how long it completes to run these
simulations. If we want all simualtions to have error better relative
error on the retraced conservation of energy than about 10<span
class="math inline">\(^{-3}\)</span>, then we must pick time steps that
are smaller than about 1/20 of the dynamical time. With this criteria
selected, we can compute the number of time steps necessary for each
globular cluster, which is a function of it’s internal dynamical time.
By doing so, I find that the fastest cluster can be computed in <span
class="math inline">\(\sim\)</span> 30 minutes. The median computation
time is <span class="math inline">\(\sim\)</span>17 hours. The largest
computation time was <span class="math inline">\(\sim\)</span> 5 days.
The total CPU time for the whole catalog is <span
class="math inline">\(\sim\)</span> 194 days.</p>
<h3 id="a-note-on-non-symplectic-integration">A note on non-symplectic
integration</h3>
<p>During the writing of this thesis, I discovered a bug in my code that
affected the integration scheme. Specifically, the error concerned the
way I handled the host orbit during the integration of the star
particles. In earlier implementations, I would integrate the orbit of
the host using the same time step that I used later to integrate the
orbits of the star particles. However, this approach violated the
structure of the leapfrog integration scheme.</p>
<p>In Hamiltonian integration, it is essential that the drift and kick
steps alternate in a consistent manner. Since I implemented a
<em>drift</em>-<em>kick</em>-<em>drift</em> (DKD) scheme, the kicks
occur at the midpoint of each time step, meaning that forces should be
evaluated at intermediate positions. Previously, I erroneously computed
the relative position vector as <span class="math display">\[\Delta
\vec{r}_i = \vec{r}_{p,i+1/2} - \vec{r}_\mathrm{GC,i},\]</span> instead
of the correct expression: <span class="math display">\[\Delta \vec{r}_i
= \vec{r}_{p,i+1/2} - \vec{r}_\mathrm{GC,i+1/2}.\]</span></p>
<p>This mistake appeared in both <span class="citation"
data-cites="2023A&amp;A...673A..44F">Ferrone et al. (2023)</span> and
<span class="citation" data-cites="2025A&amp;A...699A.289F">Ferrone et
al. (2025)</span>. Does this invalidate our results? To assess the
impact, we can compare Figs. <a
href="#fig:NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420">12</a>
and <a
href="#fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_1048576_stepsPerTau_311"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_1048576_stepsPerTau_311">[fig:NumericalErrorStreamRetrace_NGC6171_Nsteps_1048576_stepsPerTau_311]</a>.
In Fig. <a
href="#fig:NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420"
data-reference-type="ref"
data-reference="fig:NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420">12</a>,
the same retracing experiment was performed, but using the flawed
integration: the host orbit was only provided at the same grid points as
the stream. In the left panel, we see that the globular cluster does not
perfectly re-coalesce when integrating backward in time, but the result
is not catastrophic. Physically, we do not expect this process to be
perfectly time-reversible; however, such irreversibility should ideally
arise from physical modeling, not from numerical artifacts.</p>
<p>We also observe that the distribution of the relative error in energy
conservation is nearly identical between the retraced and the original
stream. In any case, once the stars move beyond the Jacobi radius, their
dynamics are dominated by the galactic potential. Since this potential
was integrated correctly and symplectically, the orbits of stars outside
the cluster remain reliable and physically meaningful.</p>
<figure
id="fig:NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420">
<img
src="images/NumericalErrorStreamRetrace_Pal5_Nsteps_32768_stepsPerTau_420.png" />
<figcaption>An illustration of how an incorrect integration scheme
breaks time reversibility. The center of mass of Palomar 5 was
integrated backward in time by 1 <span
class="math inline">\(\mathrm{s}~\frac{\mathrm{kpc}}{\mathrm{km}}\)</span>.
A Plummer sphere with 464 particles was sampled around this position
(labeled “Initial”), then integrated forward to produce the “Stream.”
The right panel shows the distribution of relative energy error. The
stream was then integrated backward in time by the same amount,
resulting in the “Retrace” configuration. The time step was chosen as a
fraction of the internal dynamical timescale, <span
class="math inline">\(\tau\)</span>.</figcaption>
</figure>
<p>As a result of this discovery, I updated the <code>tstrippy</code>
code to warn users if the host orbit is not sampled at <span
class="math inline">\(2N + 1\)</span> points, where <span
class="math inline">\(N\)</span> is the number of integration steps.
While the flawed implementation breaks strict symplecticity for the
internal cluster dynamics, the leapfrog integration for the globular
cluster orbits was still used correctly. This ensures that the cluster
center of mass returns to its present-day sky position and that stars
outside the cluster follow accurate galactic orbits. Ultimately, the
simplification of using a static Plummer sphere—whose mass and size
remain fixed—is a greater limitation than this particular numerical
error.</p>
<p>Lastly, I discovered this error while writing about the Forest-Ruth
integration method. To implement this scheme correctly, I would need to
know the position of the globular cluster’s center of mass at four
intermediate points across two time steps, with the spacing determined
by the coefficients in Table <a href="#tab:forest_ruth_coeffs"
data-reference-type="ref" data-reference="tab:forest_ruth_coeffs">2</a>.
This would require either storing additional mini-time-step data or
interpolating the globular cluster’s trajectory between saved snapshots.
Both options would necessitate a substantial refactoring of the code or
an impractical increase in memory usage per orbit. Given the results
shown in Fig. <a
href="#fig:numericalErrorMeanEnergyErrorRuthForestLeapFrog"
data-reference-type="ref"
data-reference="fig:numericalErrorMeanEnergyErrorRuthForestLeapFrog">5</a>,
the gain in accuracy does not justify the computational cost.</p>
<h2 id="the-galactic-bar">The Galactic Bar</h2>
<h3 id="the-globular-cluster-population">The globular cluster
population</h3>
<h3 id="stream-generation-in-a-barred-potential">Stream generation in a
barred potential</h3>
<h1 id="tstrippy">Tstrippy</h1>
<p>Developing my own package gave me a deeper understanding of code
structure, numerical algorithms, and the subtleties of scientific
programming. It also gave me the confidence to later use other packages
more effectively. The <code>tstrippy</code> code is available on GitHub
and runs on macOS and Linux.</p>
<ul>
<li><p>How does <code>tstrippy</code> actually work?</p></li>
<li><p>f2py?</p></li>
<li><p>setuptools <span class="math inline">\(\rightarrow\)</span>
meson</p></li>
<li><p>incompatbile with old mac processors and being blocked at numpy
1.23 until the meson migration</p></li>
<li><p>what about other codes on the market? Why did I decide to write
this code?</p></li>
</ul>
<p><span class="citation" data-cites="2018ComAC...5....2V">Varri et al.
(2018)</span> talks about a series of papers between a larger
collaboration of people who specialize in collisional dynamics and who
have performed a series of workshops together. The introduction stated
that the collaboration wants to tackle many open questions regarding
stellar clusters and build the necessary codes to interprete the future
large quantity of data that was destined to come. It has now come since
the review was 2018. An interesting point was that in general globular
clusters are approximated as being orderless, i.e. isotropic but order
does present itself within these stelalr systems. Another large problem
is no one knows what a good set of initial conditiosn is. Unresolved
binaries pose a problem because you can overestiamte the total mass of
the system. If I talk about this review, I should probably discuss some
of the results from the papers that is builds on or at least their
techinques.</p>
<p>The MODEST review led me to discover AMUSE, which is an framework for
integrating various astrophysical codes for solving 4 types of problems:
gravitational dynamics, radiative transfer, hydrodynamics, and stellar
evolution. The codes are written by the community and are interfaced
together with Amuse. The user end is python. I have spent some time
reading the book, which is instructive and well written. Steve McMillian
is one of the authors. The code has a large support on GitHub and is
still being developped. I have had trouble trying to install the code.
It seems as though their documentation is incoherrent. At one place, it
said ‘pip’ is the easiest way to install. It didn’t work. In another
place, I was instructed to install a zipped up tarball. The setup failed
becuase it expected there to be a .git file in the directory. I
successfully downloaded the code by cloneing the repository, despite the
fact that this was not recommended. I can use some aspects of the code
but not all of them. For instance, my memory tells me that about 80% of
the test suite passed, thus many scripts failed. This was when I only
installed the frame-work, which was advised since installing the whole
package is huge and unnecessary since I am not solving all astrophysical
problems. However, I wasn’t able to use one of the gravity solvers that
was presented in the textbook ‘AstrophysicalRecipes The art of AMUSE’.
The install still has some codes that failed for instance: amuse-adaptb,
amuse-hermite-grx, amuse-mi6. However, I’m hoping that this isn’t
necessary. I want to educate myself and make some examples.</p>
<p>Installing other codes and figuring out their functionalities to me
has never been trivial. This is similar to galpy when I tried to figure
out particle spray method and got less than good results. Agama also
confused me a bit. The main point is that for each package, at the end
of the day I decided that it was easier and better if I solved the
problem myself with my own code. Because, even with the other packages,
I know that they can be used to solve other astrophysical problems and
it wasn’t clear to me how to make the codes solve my specific set of of
the restricted three body problems in a potential with other perturbers
flying around.</p>
<p>In this search, I also discovered another review called
<em>Computational methods for collisional stellar systems</em> by
Spurzem and Kamlah 2023. It is also interesting and instructive. I found
it insightful when they called NBody an industry. I think the story of
GRAPE and Makino is really interesting, how he build dedicated hardware
for the nbody problem which were great for 10 years but were quickly
replaced by GPU technology.</p>
<ul>
<li><p>f2py, and why did we choose to use Fortran?</p></li>
<li><p>Bovy’s guide for making a public python package</p></li>
<li><p>migrating going from setuptools to meson</p></li>
<li><p>a brief overview of how it works.</p></li>
<li><p>how I can either save orbits or snapshots</p></li>
</ul>
<h2 id="parallelization">parallelization</h2>
<p>Since all star-particles are independent from one another, they can
be parallelized. This is <em>data</em>-parallelization, where the same
job is being performed but the input data is changed. This is a much
easier paradigm compared to <em>task</em>-parallelization different
processors do different things to do the data and may need to
communicate with one another. In this experiment, since I am simulating
the whole globular cluster catalog and sampling the orbital
uncertainties with monte-carlo, as explained in Chapter 5, I often times
parallelize over different clusters.</p>
<p>Here is an example slurm script that I use to submit all the jobs:
XXX</p>
<p>However, if I want to accelerate one particular computation, then I
must split the number of particles into batches. If I run small
simulations on my personal computer, I can take the total number of
particles and divide by the number of desired batches. Usually, I divide
into the number of processors that I am going to use. <span
class="math inline">\(N_\mathrm{per~batch}=N_p//N_\mathrm{batches}\)</span>.
However, I need to integer divide because the number of particles needs
to be an integer. Then, with the last batch, I add the remaining
particles, which is <span class="math inline">\(N_\mathrm{left over} =
N_p - N_\mathrm{batches} \times N_\mathrm{per~batch}\)</span>.</p>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-2013A&amp;A...558A..33A" class="csl-entry" role="listitem">
Astropy Collaboration, Thomas P. Robitaille, Erik J. Tollerud, Perry
Greenfield, Michael Droettboom, Erik Bray, Tom Aldcroft, et al. 2013.
<span>“<span class="nocase">Astropy: A community Python package for
astronomy</span>”</span> 558 (October):A33. <a
href="https://doi.org/10.1051/0004-6361/201322068">https://doi.org/10.1051/0004-6361/201322068</a>.
</div>
<div id="ref-2018MNRAS.478.1520B" class="csl-entry" role="listitem">
Baumgardt, H., and M. Hilker. 2018. <span>“<span class="nocase">A
catalogue of masses, structural parameters, and velocity dispersion
profiles of 112 Milky Way globular clusters</span>”</span> 478 (2):
1520–57. <a
href="https://doi.org/10.1093/mnras/sty1057">https://doi.org/10.1093/mnras/sty1057</a>.
</div>
<div id="ref-2021MNRAS.505.5957B" class="csl-entry" role="listitem">
Baumgardt, H., and E. Vasiliev. 2021. <span>“<span
class="nocase">Accurate distances to Galactic globular clusters through
a combination of Gaia EDR3, HST, and literature data</span>”</span> 505
(4): 5957–77. <a
href="https://doi.org/10.1093/mnras/stab1474">https://doi.org/10.1093/mnras/stab1474</a>.
</div>
<div id="ref-bovy_inprep" class="csl-entry" role="listitem">
Bovy, Jo. n.d. <em>Dynamics and Astrophysics of Galaxies</em>.
Princeton, NJ: Princeton University Press.
</div>
<div id="ref-2015ApJS..216...29B" class="csl-entry" role="listitem">
———. 2015. <span>“<span class="nocase">galpy: A python Library for
Galactic Dynamics</span>”</span> 216 (2): 29. <a
href="https://doi.org/10.1088/0067-0049/216/2/29">https://doi.org/10.1088/0067-0049/216/2/29</a>.
</div>
<div id="ref-1914PhRv....4..345B" class="csl-entry" role="listitem">
Buckingham, E. 1914. <span>“<span class="nocase">On Physically Similar
Systems; Illustrations of the Use of Dimensional
Equations</span>.”</span> <em>Physical Review</em> 4 (4): 345–76. <a
href="https://doi.org/10.1103/PhysRev.4.345">https://doi.org/10.1103/PhysRev.4.345</a>.
</div>
<div id="ref-2023A&amp;A...673A..44F" class="csl-entry" role="listitem">
Ferrone, Salvatore, Paola Di Matteo, Alessandra Mastrobuono-Battisti,
Misha Haywood, Owain N. Snaith, Marco Montuori, Sergey Khoperskov, and
David Valls-Gabaud. 2023. <span>“<span class="nocase">The e-TidalGCs
project. Modeling the extra-tidal features generated by Galactic
globular clusters</span>”</span> 673 (May):A44. <a
href="https://doi.org/10.1051/0004-6361/202244141">https://doi.org/10.1051/0004-6361/202244141</a>.
</div>
<div id="ref-2025A&amp;A...699A.289F" class="csl-entry" role="listitem">
Ferrone, Salvatore, Marco Montuori, Paola Di Matteo, Alessandra
Mastrobuono-Battisti, Rodrigo Ibata, Paolo Bianchini, Sergey Khoperskov,
et al. 2025. <span>“<span class="nocase">Gaps in stellar streams as a
result of globular cluster flybys: The case of Palomar 5</span>”</span>
699 (July):A289. <a
href="https://doi.org/10.1051/0004-6361/202553923">https://doi.org/10.1051/0004-6361/202553923</a>.
</div>
<div id="ref-1990PhyD...43..105F" class="csl-entry" role="listitem">
Forest, Etienne, and Ronald D. Ruth. 1990. <span>“<span
class="nocase">Fourth-order symplectic integration</span>.”</span>
<em>Physica D Nonlinear Phenomena</em> 43 (1): 105–17. <a
href="https://doi.org/10.1016/0167-2789(90)90019-L">https://doi.org/10.1016/0167-2789(90)90019-L</a>.
</div>
<div id="ref-2021A&amp;A...649A...1G" class="csl-entry" role="listitem">
Gaia Collaboration, A. G. A. Brown, A. Vallenari, T. Prusti, J. H. J. de
Bruijne, C. Babusiaux, M. Biermann, et al. 2021. <span>“<span
class="nocase">Gaia Early Data Release 3. Summary of the contents and
survey properties</span>”</span> 649 (May):A1. <a
href="https://doi.org/10.1051/0004-6361/202039657">https://doi.org/10.1051/0004-6361/202039657</a>.
</div>
<div id="ref-2023A&amp;A...674A...1G" class="csl-entry" role="listitem">
Gaia Collaboration, A. Vallenari, A. G. A. Brown, T. Prusti, J. H. J. de
Bruijne, F. Arenou, C. Babusiaux, et al. 2023. <span>“<span
class="nocase">Gaia Data Release 3. Summary of the content and survey
properties</span>”</span> 674 (June):A1. <a
href="https://doi.org/10.1051/0004-6361/202243940">https://doi.org/10.1051/0004-6361/202243940</a>.
</div>
<div id="ref-2017A&amp;A...598A..66P" class="csl-entry" role="listitem">
Pouliasis, E., P. Di Matteo, and M. Haywood. 2017. <span>“<span
class="nocase">A Milky Way with a massive, centrally concentrated thick
disc: new Galactic mass models for orbit computations</span>”</span> 598
(February):A66. <a
href="https://doi.org/10.1051/0004-6361/201527346">https://doi.org/10.1051/0004-6361/201527346</a>.
</div>
<div id="ref-1992nrca.book.....P" class="csl-entry" role="listitem">
Press, William H., Saul A. Teukolsky, William T. Vetterling, and Brian
P. Flannery. 1992. <em><span class="nocase">Numerical recipes in C. The
art of scientific computing</span></em>.
</div>
<div id="ref-2018ComAC...5....2V" class="csl-entry" role="listitem">
Varri, Anna Lisa, Maxwell Xu Cai, Francisca Concha-Ramı́rez, František
Dinnbier, Nora Lützgendorf, Václav Pavlı́k, Sara Rastello, Antonio
Sollima, Long Wang, and Alice Zocchi. 2018. <span>“<span
class="nocase">A MODEST review</span>.”</span> <em>Computational
Astrophysics and Cosmology</em> 5 (1): 2. <a
href="https://doi.org/10.1186/s40668-018-0024-6">https://doi.org/10.1186/s40668-018-0024-6</a>.
</div>
<div id="ref-2018arXiv180208255V" class="csl-entry" role="listitem">
Vasiliev, Eugene. 2018. <span>“<span class="nocase">Agama reference
documentation</span>.”</span> <em>arXiv e-Prints</em>, February,
arXiv:1802.08255. <a
href="https://doi.org/10.48550/arXiv.1802.08255">https://doi.org/10.48550/arXiv.1802.08255</a>.
</div>
<div id="ref-weyl1946classical" class="csl-entry" role="listitem">
Weyl, Hermann. 1946. <em>The Classical Groups: Their Invariants and
Representations</em>. Vol. 1. Princeton university press.
</div>
</div>
</body>
</html>
