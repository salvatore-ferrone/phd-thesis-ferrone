<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Numerics</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Numerics</h1>
</header>
<p>In line with a thesis in computational astrophysics, the equations of
motion presented here do not admit closed-form analytical solutions. As
such, we must rely on numerical methods and computer simulations to
solve them. Specifically, I solve <span class="math inline">\(N\)</span>
independent sets of Hamilton’s equations, each consisting of six
first-order, coupled differential equations.</p>
<p>Numerical integration presents several challenges. First, there is
the practical question: how do we actually solve these equations? Most
students first encounter a simple update scheme, such as Euler’s method:
<span class="math inline">\(y_{i+1} = y_i + \frac{dy}{dt}\Delta
t\)</span>. However, this quickly becomes insufficient for coupled
systems or for problems where precision and conservation laws are
essential. How can we be confident that our numerical solutions
faithfully approximate the true dynamics, especially when the true
solution is unknown? How do we handle performance, data volume, or the
trade-offs between speed and accuracy?</p>
<p>Although many software packages already exist to solve such problems,
I chose to write my own code. Some senior researchers warn, “Don’t
reinvent the wheel.” Others lamet that “the problem with the youth today
is that no one knows how the packages they use work.” Caught between
damned if I do and damned if I don’t, I decided to write my own solver
anyway. This led to the development of <code>tstrippy</code>, a code
designed to solve the restricted three-body problem. My motivation was
part practical: I wanted to avoid installation headaches, steep learning
curves, and uncertainty over whether existing tools could handle my
specific setup. But above all else, I wanted to create a reliable
product that works, allows me to reproduce my results, and run my
simulations at scale.</p>
<p>Developing my own package gave me a deeper understanding of code
structure, numerical algorithms, and the subtleties of scientific
programming. It also gave me the confidence to later use other packages
more effectively. The <code>tstrippy</code> code is available on GitHub
and runs on macOS and Linux.</p>
<p>This chapter documents how I numerically solve the equations of
motion, how I validate the accuracy of the solutions, and how the code
is organized under the hood.</p>
<h1 id="astronomical-units-and-scaling">Astronomical units and
scaling</h1>
<p>When writing any code, the choice of units is important. Astronomical
units are rarely the same as SI units. In general, the choice of units
is observationally and historically motivated, resulting in a system
that uses multiple units for the same physical quantity, which can be
confusing at first.</p>
<p>For instance, sky positions are typically reported in spherical
coordinates. Right ascension (analogous to longitude) is often expressed
in either degrees or hours, while declination (similar to latitude) is
given in degrees. Distances are reported in parsecs when derived from
parallax measurements. Line-of-sight velocities, obtained via
spectroscopic Doppler shifts, are reported in kilometers per second.
Proper motions describe angular displacements over time and are usually
reported in milliarcseconds per year. Already, we encounter several
different units for angles (degrees, hours, arcseconds), time (years,
seconds), and distance (km, kpc), none of which align with SI’s standard
units of radians, seconds, or meters, as summarized in Table <a
href="#tab:units" data-reference-type="ref"
data-reference="tab:units">1</a>.</p>
<div id="tab:units">
<table>
<caption>Units for various astronomical quantities in Galactic and SI
systems.</caption>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Distance</th>
<th style="text-align: left;">RA</th>
<th style="text-align: left;">DEC</th>
<th style="text-align: left;"><strong><span
class="math inline">\(\mathrm{v}_\mathrm{LOS}\)</span></strong></th>
<th style="text-align: left;"><span
class="math inline">\(\mu_\alpha\)</span></th>
<th style="text-align: left;"><span
class="math inline">\(\mu_\delta\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Galactic:</td>
<td style="text-align: left;"><span>[</span>kpc<span>]</span></td>
<td style="text-align: left;"><span>[</span>deg<span>]</span>
<span>[</span>HHMMSS<span>]</span></td>
<td style="text-align: left;"><span>[</span>deg<span>]</span></td>
<td style="text-align: left;">km/s</td>
<td style="text-align: left;"><span>[</span>mas/yr<span>]</span></td>
<td style="text-align: left;"><span>[</span>mas/yr<span>]</span></td>
</tr>
<tr>
<td style="text-align: left;">S.I.</td>
<td style="text-align: left;"><span>[</span>m<span>]</span></td>
<td style="text-align: left;"><span>[</span>rad<span>]</span></td>
<td style="text-align: left;"><span>[</span>rad<span>]</span></td>
<td style="text-align: left;">m/s</td>
<td style="text-align: left;"><span>[</span>rad/s<span>]</span></td>
<td style="text-align: left;"><span>[</span>rad/s<span>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>This raises practical concerns—for example, what would be the unit of
acceleration? km/s<span class="math inline">\(^2\)</span>?
parsec/year/second? To systematically manage units, we turn to
dimensional analysis, notably the Buckingham Pi theorem. In classical
mechanics, physical quantities are typically expressed in terms of three
fundamental dimensions: length, time, and mass. Any quantity can then be
represented as a product of powers of these base units:</p>
<p><span class="math display">\[\left[\mathrm{Quantity}\right] =
\mathcal{l}^a t^b m^c =
            \begin{bmatrix}
                a\\
                b\\
                c
            \end{bmatrix}\]</span></p>
<p>For example, velocity has dimensions <span class="math inline">\([1,
-1, 0]\)</span>, momentum is <span class="math inline">\([1, -1,
1]\)</span>, and acceleration is <span class="math inline">\([1, -2,
0]\)</span>.</p>
<p>It is not strictly necessary to adopt length-time-mass as the
fundamental basis, as long as the three chosen base units are linearly
independent. In stellar dynamics, it is often more natural to use
distance, velocity, and mass as the base units. In this thesis, I
adopt:</p>
<ul>
<li><p>Distance: 1 kpc</p></li>
<li><p>Velocity: 1 km/s</p></li>
<li><p>Mass: 1 solar mass <span
class="math inline">\(\mathrm{M}_\odot\)</span></p></li>
</ul>
<p>In this system, time has derived units of: <span
class="math display">\[\left[t\right] =
\frac{\mathrm{distance}}{\mathrm{velocity}} =
\frac{\mathrm{kpc}}{\mathrm{km/s}}.\]</span> While not immediately
intuitive, this unit of time is convenient because: <span
class="math display">\[1\frac{\mathrm{kpc}}{\mathrm{Gyr}} \approx
1\frac{\mathrm{km}}{\mathrm{s}}.\]</span></p>
<p>The gravitational constant has dimensions: <span
class="math display">\[\left[G\right]=\frac{v^2 \cdot l}{m},\]</span>
which evaluates numerically in these units as: <span
class="math display">\[G = 4.301 \times 10^{-6}
\left(\mathrm{km}/\mathrm{s}\right)^2 \cdot \mathrm{kpc} \cdot
\mathrm{M}_\odot^{-1}.\]</span></p>
<p>Once the base units are defined, derived quantities such as
acceleration follow directly. Whether considering acceleration as <span
class="math inline">\(v^2~l^{-1}\)</span> or <span
class="math inline">\(l \cdot t^{-2}\)</span>, they are equivalent and
yield: <span
class="math inline">\(\left(\mathrm{kpc}/\mathrm{s}\right)^2 \cdot
\mathrm{kpc}^{-1}\)</span>.</p>
<p>It is worth mentioning that <span
class="math inline">\(N\)</span>-body codes often simplify further by
selecting distance, velocity, and the gravitational constant as the base
units, setting <span class="math inline">\(G = 1\)</span>. While this
simplifies force computations, it introduces less intuitive units for
mass. For instance, by choosing 1 kpc for distance and 1 km/s for
velocity, and setting <span class="math inline">\(G = 1\)</span>, the
derived mass unit becomes: <span
class="math display">\[\left[\mathrm{mass}\right] = \frac{l \cdot
v^2}{G} = 232509~\mathrm{M}_\odot.\]</span></p>
<p>This approach was used in our first paper (see Chapter 4). Another
example is the case of <code>Galpy</code>. <span class="citation"
data-cites="2015ApJS..216...29B">Bovy (2015)</span> introduced
<em>natural units</em> motivated by the galaxy’s rotation curve,
embodied in: <span class="math display">\[\frac{v_\mathrm{circ}^2}{R_0}
= \nabla  \Phi \left(R_0, z=0\right),
        \label{eq:vcirc}\]</span> which is the circular velocity in a
cylindrically symmetric potential evaluated in the plane. In this
normalization, <span class="math inline">\(R\)</span> is the cylindrical
scale length of the galaxy, and <span
class="math inline">\(v_\mathrm{circ}\)</span> is the circular velocity
at this radius, both of which are set to 1. The gravitational constant
is also set to 1. Whatever the form of the potential, the scale lengths
must be normalized to <span class="math inline">\(R\)</span>, and the
mass parameter is subsequently determined through Eq. <a
href="#eq:vcirc" data-reference-type="ref"
data-reference="eq:vcirc">[eq:vcirc]</a>. The total potential is a
linear combination of individual components, with the user selecting the
contribution of each component to the force at the characteristic
radius. For example, <span class="math inline">\(\Phi = \sum_i
a_i\Phi_i\)</span>, where <span class="math inline">\(a_i\)</span> are
weights such that <span class="math inline">\(\nabla \Phi_i(R_0, z=0) =
a_i\)</span> in normalized units.</p>
<p>In this system of units, emphasis is placed on the rotation curve and
how much each component contributes to it at the reference radius of the
galaxy. Note that <span
class="math inline">\(v_\mathrm{circ}(R_0)\)</span> is not necessarily
the maximum value of the rotation curve.</p>
<p>In short, each code presents its own preferred units and
normalization. It is the job of a computational astrophysicist to
understand these conventions and be able to convert between them and
observable quantities. <span class="math inline">\(N\)</span>-body codes
work best when setting <span class="math inline">\(G = 1\)</span>, while
<code>Galpy</code> uses natural units that emphasize the rotational
properties of a galaxy. <code>Tstrippy</code>, by contrast, expects the
user to pass masses in solar masses, velocities in kilometers per
second, and distances in kiloparsecs. However, physical constants are
not hard-coded, so the user may pass any numerical values to the code as
long as they are based on a self-consistent unit system. The code
includes the <code>Pouliasis2017pii</code> potential and a catalog of
galactic globular cluster properties, both reported in the
aforementioned units.</p>
<p>A valid general strategy when developing numerical codes is to
implement a module that converts user-defined units to the internal
units of the code. This functionality also exists in <code>Galpy</code>
and a similar system is implemented in <code>Agama</code> <span
class="citation" data-cites="2018arXiv180208255V">(Vasiliev
2018)</span>. I chose not to add such a layer to <code>Tstrippy</code>,
since my goal was not to develop the most robust tool in the field, but
rather to answer specific scientific questions. That said,
<code>Astropy</code> provides an excellent unit-handling module that
allows users to convert between units easily <span class="citation"
data-cites="2013A&amp;A...558A..33A">(Astropy Collaboration et al.
2013)</span>, and I recommend its use in the documentation.</p>
<p>In the end, I chose this unit convention because I believe it is the
most intuitive for users and aligns with how quantities are typically
reported in galactic astronomy.</p>
<h1 id="solving-the-equations-of-motion">Solving the equations of
motion</h1>
<p>Long before the advent of computers, Euler proposed a simple method
for numerically solving differential equations. However, it is
inefficient and inaccurate for coupled systems, especially when
long-term behavior matters. In the case of Hamiltonian systems, we can
exploit specific geometric properties to design numerical schemes that
better preserve the qualitative features of the true solution.</p>
<p>In this thesis, I implemented the Leapfrog integrator and the
Forest-Ruth scheme. These schemes are derived from the structure of
Hamiltonian mechanics and are known as <em>symplectic integrators</em>.
Before continuing, I would like to quote <span class="citation"
data-cites="bovy_inprep">(Bovy, n.d.)</span>:</p>
<blockquote>
<p>Hamiltonian integrators are often called symplectic. This name comes
from the fact that these integrators are Hamiltonian maps, whose
mathematical structure is that of a vector flow on a symplectic
manifold. Many fine dynamicists have made great contributions to the
field without delving deeply into the meaning of the previous sentence
and we do not discuss this further.</p>
</blockquote>
<p>However, my curiosity about linguistics pushed me to delve further:
What does <em>symplectic</em> mean? <span class="citation"
data-cites="weyl1946classical">Weyl (1946)</span> coined the term
because <em>complex</em> was already taken. The prefix <em>com</em>
refers to together, and “plexus” comes from greek meaning “woven” or
“braided”. So from its roots, “complex” means something composed of
interwoven parts. The image of tangled braids captures the idea well.
Similarly, “sym-” is a Greek prefix meaning “together.” The idea remains
the same: in Hamiltonian dynamics, the evolution of position and
momentum are interdependent. This becomes clearer in matrix form: <span
class="math display">\[\begin{bmatrix}
            \dot{\bf{q}}\\
            \dot{\bf{p}}
        \end{bmatrix}
         =
        \begin{bmatrix}
            0 &amp; I_n \\
            -I_n &amp; 0
        \end{bmatrix}
                \begin{bmatrix}
            \frac{\partial \mathcal{H}}{\partial \bf{q}} \\
            \frac{\partial \mathcal{H}}{\partial \bf{p}}
        \end{bmatrix}
        \label{eq:symplectic}\]</span> Here, the skew-symmetric matrix
“weaves” the positions and momenta together.</p>
<p>Although the equations of motion do not admit analytical solutions,
they possess several known properties. First, trajectories governed
solely by gravity are time-reversible. This property is important for my
methodology, where I integrate the equations of motion backward in time
and then forward again to the present-day position. Secondly, the total
orbital energy is conserved. Moreover, according to Liouville’s theorem,
Hamiltonian flows preserve the local phase space volume. A corollary of
this is that the determinant of the Jacobian matrix of the
transformation from <span
class="math inline">\(\left(q,p\right)\rightarrow
\left(q&#39;,p&#39;\right)\)</span> must be one, which means that the
transformation only rotates or translates an infinitesimal volume but
does not shrink or expand the volume. We can view the transform as:
<span class="math display">\[\begin{aligned}
        q&#39; &amp;= q + \frac{\partial \mathcal{H}}{\partial p}\Delta
t, \\
        p&#39; &amp;= -\frac{\partial \mathcal{H}}{\partial q}\Delta t +
p,
    
\end{aligned}\]</span> The Jacobian matrix is given by <span
class="math inline">\(\left(\frac{\partial x_i&#39;}{\partial x_j
}\right)\)</span>: <span class="math display">\[\begin{bmatrix}
            1 &amp; \Delta t \frac{\partial^2 \mathcal{H}}{\partial p^2}
\\  
            -\Delta t \frac{\partial^2 \mathcal{H}}{\partial q^2} &amp;
1 \\  
        \end{bmatrix}\]</span> and the subsequent determinant is: <span
class="math display">\[\mathrm{det}\left(J\right) = 1 - \Delta t^2
\frac{\partial^2 \mathcal{H}}{\partial q^2} \frac{\partial^2
\mathcal{H}}{\partial p^2}.\]</span> In general, neither <span
class="math inline">\(\frac{\partial^2 \mathcal{H}}{\partial
q^2}\)</span> or <span class="math inline">\(\frac{\partial^2
\mathcal{H}}{\partial p^2}\)</span> are zero. Therefore, to preserve
phase-space volume, we update positions and momenta in alternating
steps. The transformation order becomes: <span
class="math inline">\((q,p) \rightarrow (q&#39;,p) \rightarrow
(q&#39;,p&#39;)\)</span>. This is commonly referred to as a sequence of
<em>drifts</em> and <em>kicks</em>. A <em>drift</em> updates the
position while holding the momentum fixed, and a <em>kick</em> updates
the momentum while holding the position fixed. Symplectic integrators
alternate these operations in a specific sequence to preserve the
structure of Hamiltonian flow.</p>
<p>The scheme outlined above is essentially a first-order method and is
closely related to Euler’s method. More sophisticated integrators use
values from multiple time steps to construct higher-order estimates of
the system’s evolution. For example, some schemes temporarily evolve the
position to an intermediate value <span
class="math inline">\(q_\mathrm{temp}\)</span>, use this to compute a
momentum <span class="math inline">\(p_\mathrm{temp}\)</span>, and then
adjust both using weighted averages or predictor-corrector steps to
reach the final state. These methods carefully balance forward and
backward steps to optimize accuracy while preserving the symplectic
structure.</p>
<p>One of the most commonly used integrators in galactic dynamics is the
leapfrog method. It works by interleaving updates of positions and
momenta using time-centered averages. Specifically, the average momentum
between <span class="math inline">\(q_i\)</span> and <span
class="math inline">\(q_{i+1}\)</span> (denoted <span
class="math inline">\(p_{i+1/2}\)</span>) is used to advance the
position, and then the average force (derived from the potential) is
used to update the momentum. In Cartesian coordinates—used throughout
this thesis—the leapfrog algorithm can be rewritten in terms of
grid-aligned quantities:</p>
<p><span class="math display">\[\begin{aligned}
        x_{i+1} &amp;= x_i + \dot{x}_i \Delta t + \frac{1}{2}\ddot{x}_i
\Delta t^2, \\
        \ddot{x}_{i+1} &amp;= -\nabla \Phi(x_{i+1}), \\
        \dot{x}_{i+1} &amp;= \dot{x}_i + \frac{1}{2}\left(\ddot{x}_i +
\ddot{x}_{i+1}\right)\Delta t.
    
\end{aligned}\]</span> This formulation highlights how the leapfrog
method naturally incorporates the second-order accuracy and
time-reversibility essential for modeling gravitational systems over
long timescales. As I will show in the next section, the leapfrog
algorithm is sufficient for the problems that I solve. However, the
question of computational efficiency and numerical accuracy is ever
present. Leapfrog uses uses the two local points about the position and
momenta to evolve them. Other schema can use more points to have more
accurate estimations for the local derivatives.</p>
<p><span class="citation" data-cites="1990PhyD...43..105F">Forest and
Ruth (1990)</span> proposed one such method for symplectic integrations,
which is our situation here. The method is complicated and involves
finding roots of high order polynomials, and the roots of which
determine the weights and distances about the local point for finding
the best estimate of the derivative for evoling the system. The method
involves solving a cubic polynomial to determine the optimal
coefficients. While the derivation is mathematically involved, the final
scheme is straightforward to implement. Nonetheless, I implemented this
method and tested its efficiency against the leapfrog. There are eight
coefficients in this method, which are presented in table <a
href="#tab:forest_ruth_coeffs" data-reference-type="ref"
data-reference="tab:forest_ruth_coeffs">2</a>.</p>
<div id="tab:forest_ruth_coeffs">
<table>
<caption>Velocity (<span class="math inline">\(c_n\)</span>) and
acceleration (<span class="math inline">\(d_n\)</span>) coefficients for
the Forest-Ruth symplectic integrator.</caption>
<tbody>
<tr>
<td colspan="4" style="text-align: center;">Velocity coefficients (<span
class="math inline">\(c_n\)</span>)</td>
<td colspan="4" style="text-align: center;">Acceleration coefficients
(<span class="math inline">\(d_n\)</span>)</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(c_1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(c_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(c_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(c_4\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(d_4\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(w +
\frac{1}{2}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-w\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-w\)</span></td>
<td style="text-align: center;"><span class="math inline">\(w +
\frac{1}{2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2w +
1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-4w -
1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2w +
1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>The coefficients are all based on the solution to the cubic
polynomial: <span class="math inline">\(48 w^3 + 24 w^2 - 1 =
0\)</span>. For a single step, the positions and velocities are updated
as follows: <span class="math display">\[\begin{aligned}
        x&#39; &amp;= x + c_n v \Delta t \\
        t&#39; &amp;= t + c_n \Delta t \\
        \ddot{x} &amp;= \nabla \Phi (x&#39;) \\
        \dot{x}&#39; &amp;= \dot{x} + d_n \ddot{x} \Delta t,
    
\end{aligned}\]</span> where <span class="math inline">\(n\)</span> is
the <em>mini-step</em>. Notice that the sum of <span
class="math inline">\(\sum_n^4 c_n\)</span> and <span
class="math inline">\(\sum_n^4 d_n\)</span> both equal 1, which is a
full time step <span class="math inline">\(\Delta t\)</span>.</p>
<p>Lastly, it is important to note that the leapfrog algorithm is
symplectic and time-reversible only for Hamiltonians that are both
time-independent and separable—that is, where the Hamiltonian can be
written as a sum of a kinetic term depending only on momenta, <span
class="math inline">\(T(p)\)</span> and whose potential depends only on
position <span class="math inline">\(\Phi(q)\)</span>. These conditions
are satisfied for systems in an inertial frame with conservative forces.
This is true when I integrate the motion for the center of mass of the
globular clusters. However, the Hamiltonian for the integration of the
particles does depend on time. So the leapfrog algorithm may introduce
systematic integration errors due to the violation of its underlying
assumptions, beyond ordinary rounding errors.</p>
<p>Similarly, when we integrate the orbits of either the particles or
the globular clusters in the galaxy containing a galactic bar, we are
faced with a choice: we can either work in a time-dependent inertial
frame, where the potential rotates and the Hamiltonian explicitly
depends on time, or we can transform to a rotating frame, in which case
the kinetic energy becomes position-dependent due to Coriolis and
centrifugal forces, which breaks the necessary criteron of separability:
<span class="math inline">\(\mathcal{H}(q,p) = T(p)+\Phi(q)\)</span>. In
both cases, the standard assumptions of the leapfrog algorithm are
violated.</p>
<p>Nonetheless, we will continue to use leapfrog as it remains a robust
and efficient integrator for a wide range of astrophysical systems. Its
good long-term energy behavior makes it a reasonable approximation even
when the ideal assumptions are not strictly met. However, this
highlights the need for careful validation: we must verify that the
integration errors remain within acceptable bounds, especially in
systems with non-separable or time-dependent dynamics. This validation
is the subject of the next section.</p>
<h1 id="numerical-error">Numerical error</h1>
<ul>
<li><p>what’s the right time step?</p></li>
<li><p>dynamical time</p></li>
<li><p>compute the energy conservation</p></li>
<li><p>reverse integratbility</p></li>
<li><p>throwing outdata and then re-interpolating</p></li>
<li><p>show some nice graphs</p></li>
</ul>
<figure id="fig:numericalErrorLeapFrogVanilla.png">
<img src="images/numericalErrorLeapFrogVanilla.png" />
<figcaption aria-hidden="true"></figcaption>
</figure>
<figure id="fig:numericalErrorReverseIntegration.png">
<img src="images/numericalErrorReverseIntegration.png" />
<figcaption aria-hidden="true"></figcaption>
</figure>
<figure id="fig:numericalErrorGlobularClustersComputationTime.png">
<img src="images/numericalErrorGlobularClustersComputationTime.png" />
<figcaption aria-hidden="true"></figcaption>
</figure>
<figure id="fig:numericalErrorRuthForest.png">
<img src="images/numericalErrorRuthForest.png" />
<figcaption aria-hidden="true"></figcaption>
</figure>
<figure id="fig:numericalErrorMeanEnergyErrorRuthForestLeapFrog.png">
<img src="images/numericalErrorMeanEnergyErrorRuthForestLeapFrog.png" />
<figcaption aria-hidden="true"></figcaption>
</figure>
<h1 id="computation-time-and-data-volume">Computation time and Data
Volume</h1>
<p>Another important aspect of this</p>
  <div class="video-container">
    <video controls style="max-width: 100%;">
      <source src="videos/cluster_showing_scale_and_dynamical_time.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>
  </div>
<h1 id="tstrippy">Tstrippy</h1>
<ul>
<li><p>How does <code>tstrippy</code> actually work?</p></li>
<li><p>f2py?</p></li>
<li><p>setuptools <span class="math inline">\(\rightarrow\)</span>
meson</p></li>
<li><p>incompatbile with old mac processors and being blocked at numpy
1.23 until the meson migration</p></li>
<li><p>what about other codes on the market? Why did I decide to write
this code?</p></li>
</ul>
<p><span class="citation" data-cites="2018ComAC...5....2V">Varri et al.
(2018)</span> talks about a series of papers between a larger
collaboration of people who specialize in collisional dynamics and who
have performed a series of workshops together. The introduction stated
that the collaboration wants to tackle many open questions regarding
stellar clusters and build the necessary codes to interprete the future
large quantity of data that was destined to come. It has now come since
the review was 2018. An interesting point was that in general globular
clusters are approximated as being orderless, i.e. isotropic but order
does present itself within these stelalr systems. Another large problem
is no one knows what a good set of initial conditiosn is. Unresolved
binaries pose a problem because you can overestiamte the total mass of
the system. If I talk about this review, I should probably discuss some
of the results from the papers that is builds on or at least their
techinques.</p>
<p>The MODEST review led me to discover AMUSE, which is an framework for
integrating various astrophysical codes for solving 4 types of problems:
gravitational dynamics, radiative transfer, hydrodynamics, and stellar
evolution. The codes are written by the community and are interfaced
together with Amuse. The user end is python. I have spent some time
reading the book, which is instructive and well written. Steve McMillian
is one of the authors. The code has a large support on GitHub and is
still being developped. I have had trouble trying to install the code.
It seems as though their documentation is incoherrent. At one place, it
said ‘pip’ is the easiest way to install. It didn’t work. In another
place, I was instructed to install a zipped up tarball. The setup failed
becuase it expected there to be a .git file in the directory. I
successfully downloaded the code by cloneing the repository, despite the
fact that this was not recommended. I can use some aspects of the code
but not all of them. For instance, my memory tells me that about 80% of
the test suite passed, thus many scripts failed. This was when I only
installed the frame-work, which was advised since installing the whole
package is huge and unnecessary since I am not solving all astrophysical
problems. However, I wasn’t able to use one of the gravity solvers that
was presented in the textbook ‘AstrophysicalRecipes The art of AMUSE’.
The install still has some codes that failed for instance: amuse-adaptb,
amuse-hermite-grx, amuse-mi6. However, I’m hoping that this isn’t
necessary. I want to educate myself and make some examples.</p>
<p>Installing other codes and figuring out their functionalities to me
has never been trivial. This is similar to galpy when I tried to figure
out particle spray method and got less than good results. Agama also
confused me a bit. The main point is that for each package, at the end
of the day I decided that it was easier and better if I solved the
problem myself with my own code. Because, even with the other packages,
I know that they can be used to solve other astrophysical problems and
it wasn’t clear to me how to make the codes solve my specific set of of
the restricted three body problems in a potential with other perturbers
flying around.</p>
<p>In this search, I also discovered another review called
<em>Computational methods for collisional stellar systems</em> by
Spurzem and Kamlah 2023. It is also interesting and instructive. I found
it insightful when they called NBody an industry. I think the story of
GRAPE and Makino is really interesting, how he build dedicated hardware
for the nbody problem which were great for 10 years but were quickly
replaced by GPU technology.</p>
<ul>
<li><p>f2py, and why did we choose to use Fortran?</p></li>
<li><p>Bovy’s guide for making a public python package</p></li>
<li><p>migrating going from setuptools to meson</p></li>
<li><p>a brief overview of how it works.</p></li>
<li><p>how I can either save orbits or snapshots</p></li>
</ul>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-2013A&amp;A...558A..33A" class="csl-entry" role="listitem">
Astropy Collaboration, Thomas P. Robitaille, Erik J. Tollerud, Perry
Greenfield, Michael Droettboom, Erik Bray, Tom Aldcroft, et al. 2013.
<span>“<span class="nocase">Astropy: A community Python package for
astronomy</span>”</span> 558 (October):A33. <a
href="https://doi.org/10.1051/0004-6361/201322068">https://doi.org/10.1051/0004-6361/201322068</a>.
</div>
<div id="ref-bovy_inprep" class="csl-entry" role="listitem">
Bovy, Jo. n.d. <em>Dynamics and Astrophysics of Galaxies</em>.
Princeton, NJ: Princeton University Press.
</div>
<div id="ref-2015ApJS..216...29B" class="csl-entry" role="listitem">
———. 2015. <span>“<span class="nocase">galpy: A python Library for
Galactic Dynamics</span>”</span> 216 (2): 29. <a
href="https://doi.org/10.1088/0067-0049/216/2/29">https://doi.org/10.1088/0067-0049/216/2/29</a>.
</div>
<div id="ref-1990PhyD...43..105F" class="csl-entry" role="listitem">
Forest, Etienne, and Ronald D. Ruth. 1990. <span>“<span
class="nocase">Fourth-order symplectic integration</span>.”</span>
<em>Physica D Nonlinear Phenomena</em> 43 (1): 105–17. <a
href="https://doi.org/10.1016/0167-2789(90)90019-L">https://doi.org/10.1016/0167-2789(90)90019-L</a>.
</div>
<div id="ref-2018ComAC...5....2V" class="csl-entry" role="listitem">
Varri, Anna Lisa, Maxwell Xu Cai, Francisca Concha-Ramı́rez, František
Dinnbier, Nora Lützgendorf, Václav Pavlı́k, Sara Rastello, Antonio
Sollima, Long Wang, and Alice Zocchi. 2018. <span>“<span
class="nocase">A MODEST review</span>.”</span> <em>Computational
Astrophysics and Cosmology</em> 5 (1): 2. <a
href="https://doi.org/10.1186/s40668-018-0024-6">https://doi.org/10.1186/s40668-018-0024-6</a>.
</div>
<div id="ref-2018arXiv180208255V" class="csl-entry" role="listitem">
Vasiliev, Eugene. 2018. <span>“<span class="nocase">Agama reference
documentation</span>.”</span> <em>arXiv e-Prints</em>, February,
arXiv:1802.08255. <a
href="https://doi.org/10.48550/arXiv.1802.08255">https://doi.org/10.48550/arXiv.1802.08255</a>.
</div>
<div id="ref-weyl1946classical" class="csl-entry" role="listitem">
Weyl, Hermann. 1946. <em>The Classical Groups: Their Invariants and
Representations</em>. Vol. 1. Princeton university press.
</div>
</div>
</body>
</html>
