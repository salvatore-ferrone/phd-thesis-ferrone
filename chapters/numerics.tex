In line with a thesis in computational astrophysics, the equations of motion presented here do not admit closed-form analytical solutions. As such, we must rely on numerical methods and computer simulations to solve them. Specifically, I solve $N$ independent sets of Hamilton's equations, each consisting of six first-order, coupled differential equations.

Numerical integration presents several challenges. First, there is the practical question: how do we actually solve these equations? Most students first encounter a simple update scheme, such as Euler's method: $y_{i+1} = y_i + \frac{dy}{dt}\Delta t$. However, this quickly becomes insufficient for coupled systems or for problems where precision and conservation laws are essential. How can we be confident that our numerical solutions faithfully approximate the true dynamics, especially when the true solution is unknown? How do we handle performance, data volume, or the trade-offs between speed and accuracy?

Although many software packages already exist to solve such problems, I chose to write my own code. Some senior researchers warn, ``Don't reinvent the wheel.'' Others lamet that ``the problem with the youth today is that no one knows how the packages they use work.'' Caught between damned if I do and damned if I don't, I decided to write my own solver anyway. This led to the development of \texttt{tstrippy}, a code designed to solve the restricted three-body problem. My motivation was part practical: I wanted to avoid installation headaches, steep learning curves, and uncertainty over whether existing tools could handle my specific setup. But above all else, I wanted to create a reliable product that works, allows me to reproduce my results, and run my simulations at scale. 

Developing my own package gave me a deeper understanding of code structure, numerical algorithms, and the subtleties of scientific programming. It also gave me the confidence to later use other packages more effectively. The \texttt{tstrippy} code is available on GitHub and runs on macOS and Linux.

This chapter documents how I numerically solve the equations of motion, how I validate the accuracy of the solutions, and how the code is organized under the hood.



\section{Astronomical units and scaling}

    When writing any code, the choice of units is important. Astronomical units are rarely the same as SI units. In general, the choice of units is observationally and historically motivated, which results in a system that uses multiple units for the same quantity, which can be confusing at first. To start, since we are observing the sky, everything is reported in spherical coordinates. Positions on the sky are reported in degrees, or for the right ascension, the equivalent of longitude, even in hour angle. Distances to the Earth are reported in parsecs since they are derived from measuring the parallax angle (if they are derived from the parallax angle and not other methods). Line-of-sight velocities are reported in kilometers per second, as they are determined through spectroscopy to measure the relativistic Doppler effect. Then, the proper motions are reported based on the hour angle, which is the change in a given star's position on the celestial sphere from one year to the next, which is millarcseconds per year. So far, we have three units for angular position, none of which are the SI's radians. We use kilometers and parsecs for distance, and years and seconds are units of time. How do we resolve this mess?  For example, what would the unit of acceleration be? km/s^2? parsec/year/second?

    Units are a solved problem and are best presented through the Buckingham PI theorem. When considering issues of ordinary mechanics, we can choose a set of basis vectors that are distance, time, and mass. All other quantities are expressed as a linear combination of their exponents: [units] = $\mathcal{l}^a\times t^b\times m^c = \begin{bmatrix} a\\b\\c \end{bmatrix}$. Velocity is [1,-1,0], momentum is [1,-1,1], and acceleration is [1,-2,0]. 

    Note that there are no fundamental dimensions; we can describe any quantity as long as we span and that all basis vectors are linearly independent. In stellar dynamics, distance, time, and often not chosen as the basis vectors. I choose the basis vectors as distance, velocity, and mass, with units of kpc, km/s, and solar masses, respectively. As a result, time is a unit [1,-1,0], which is s kpc/km. As a consequence, time is not an ``intuitive'' unit, like years. However, the universe helped us out in that 1 kpc / Gyr $\approx$ 1 km /s. 

    The gravitational constant can be converted to these units 

    \begin{table}[]
        \caption{Units for various astronomical quantities in Galactic and SI systems.}
        \label{tab:units}
        \begin{tabular}{l|l|l|l|l|l|l|}
                            & Distance  & RA                     & DEC                    & \textbf{$\mathrm{v}_\mathrm{LOS}$} & $\mu_\alpha$ & $\mu_\delta$ \\ \hline
            Galactic: & {[}kpc{]} & {[}deg{]} {[}HHMMSS{]} & {[}deg{]}  & km/s                      & {[}mas/yr{]} & {[}mas/yr{]} \\ \hline
            S.I.       & {[}m{]}   & {[}rad{]}              & {[}rad{]}              & m/s                       & {[}rad/s{]}  & {[}rad/s{]}  \\ 
        \end{tabular}
    \end{table}


\section{Tstrippy}

    \citet{2018ComAC...5....2V} talks about a series of papers between a larger collaboration of people who specialize in collisional dynamics and who have performed a series of workshops together. The introduction stated that the collaboration wants to tackle many open questions regarding stellar clusters and build the necessary codes to interprete the future large quantity of data that was destined to come. It has now come since the review was 2018. An interesting point was that in general globular clusters are approximated as being orderless, i.e. isotropic but order does present itself within these stelalr systems. Another large problem is no one knows what a good set of initial conditiosn is. Unresolved binaries pose a problem because you can overestiamte the total mass of the system. If I talk about this review, I should probably discuss some of the results from the papers that is builds on or at least their techinques.

    The MODEST review led me to discover AMUSE, which is an framework for integrating various astrophysical codes for solving 4 types of problems: gravitational dynamics, radiative transfer, hydrodynamics, and stellar evolution. The codes are written by the community and are interfaced together with Amuse. The user end is python. I have spent some time reading the book, which is instructive and well written. Steve McMillian is one of the authors. The code has a large support on GitHub and is still being developped. I have had trouble trying to install the code. It seems as though their documentation is incoherrent. At one place, it said `pip' is the easiest way to install. It didn't work. In another place, I was instructed to install a zipped up tarball. The setup failed becuase it expected there to be a .git file in the directory. I successfully downloaded the code by cloneing the repository, despite the fact that this was not recommended. I can use some aspects of the code but not all of them. For instance, my memory tells me that about 80\% of the test suite passed, thus many scripts failed. This was when I only installed the frame-work, which was advised since installing the whole package is huge and unnecessary since I am not solving all astrophysical problems. However, I wasn't able to use one of the gravity solvers that was presented in the textbook `AstrophysicalRecipes The art of AMUSE'. The install still has some codes that failed for instance: amuse-adaptb, amuse-hermite-grx, amuse-mi6. However, I'm hoping that this isn't necessary. I want to educate myself and make some examples. 

    Installing other codes and figuring out their functionalities to me has never been trivial. This is similar to galpy when I tried to figure out particle spray method and got less than good results. Agama also confused me a bit. The main point is that for each package, at the end of the day I decided that it was easier and better if I solved the problem myself with my own code. Because, even with the other packages, I know that they can be used to solve other astrophysical problems and it wasn't clear to me how to make the codes solve my specific set of of the restricted three body problems in a potential with other perturbers flying around. 

    In this search, I also discovered another review called \textit{Computational methods for collisional stellar systems} by Spurzem and Kamlah 2023. It is also interesting and instructive. I found it insightful when they called NBody an industry. I think the story of GRAPE and Makino is really interesting, how he build dedicated hardware for the nbody problem which were great for 10 years but were quickly replaced by GPU technology. 
    \begin{itemize}
        \item f2py, and why did we choose to use Fortran? 
        \item Bovy's guide for making a public python package
        \item migrating going from setuptools to meson
        \item a brief overview of how it works. 
        \item how I can either save orbits or snapshots
    \end{itemize}



\section{Numerical Errors and Schema} 

    If we consider the following differential equation, $\frac{dy}{dt}=m$, whose general solution is: $y=mt+b$. If we are working double-precision numbers who use 64-bits to represent real numbers, then the general solution is only 16 bytes. However, if we use newton's method to find a particular solution given an initial condition $b$, then we must evaluate $t_i,y_i$ at each time step considered. The data volume becomes $2\times N_\mathrm{steps}\times 8 \mathrm{bytes}$. 

    With numerical solutions in general, we have a set of initial conditions, and evaluting Hamilton's equations at them provides the instantaneous evolution of the system. If we use a sufficiently small time step, we can then find the next state of the system. \textit{Sufficiently small} means that the numerical solution converges to the \textit{true solution} and only differs by accumulated numerical error from machine precision. 

    \begin{verbatim}
    VIDEO: cluster_showing_scale_and_dynamical_time.mp4
    \end{verbatim}
    Display here some results where I tried to use the higher order leap frog... i.e. the Ruth method. 

    Make a qualitative argument against the 

    \begin{itemize}
        \item leapfrog is sympletic, preserve hamiltonian in the transform
        \item integrating at high resolution, downsampling for storage, and then interpolating if higher resolution is needed. 
        \item I tried to implement the Ruth-Ford
        \item I tried to implement the king model, which was slower and worse and not worth it 
    \end{itemize}


    \section{Computation time and Data Volume}
    \begin{itemize}
        \item there are practical restraints
        \item we choose to solve the restricted three body problem b/c
    \end{itemize}

\section{My work flow}
    \begin{itemize}
        \item Tstrippy is the production code
        \item then I have gcs which does data i/o
        \item then I have an analysis package that makes plots based on the final data products
    \end{itemize}

